<body>
A set of common utilities used by either proxy, or server items.  Since the
client would not have these classes locally, the ones used from this package
must be sent to its RMIClassLoader. As a general rule, do not compile all of
the utility classes blindly; rather jar any classes resulting from the
compilation of the proxy or server items.<br><br>
Fundamentally, there are two entities; clients and servers. A server is a
Virtual Machine which, at a minimum, exports one item, meaning a remotely
invokable object implementing the {@link gnu.cajo.invoke.Invoke Invoke}
interface.  A server can also provide proxies; i.e. executable interfaces to
the server's local item objects, which run inside the client's runtime. A
client makes use of a server's items and proxies, but need not export any of
its own. Certainly, the architecture supports the notion of hybrid
client/server machines.  Each virtual machine can export as many items as it
wants.
<p>Items can connect to other items across either, logically, virtually and
physically separated items. This package seeks to establish the following
roles between items:<p>
An item is the control element of the system, it performs three major
tasks:<ul>
  <li>control system resources
  <li>monitor system operation
  <li>log system transactions
</ul>A proxy is a optional, item-specific, interface program, designed to
separate and manage the following functions:<ul>
  <li>item data formatting and presentation
  <li>user input; validation, and feedback
  <li>localization and internationalization
</ul>Each item instance can invoke a remote method invocation on another.
The invocation may or may not carry inbound data, and may or may not
result in a synchronous response of data.  A remote method invocation may
also initiate an asynchronous operation in the receiver, resulting in a
subsequent RMI invocation from the receiver back to the client, at a later
time.<p>
The overall network structure looks something like this:<pre>

 --------------         --------------
|  Server VM   |       |  Client VM   |
|  ----------  | TCP   |  ----------  |
| | Item     | | links | | Proxy    | |
| |----------| |       | |----------| |
| | http     | |<------| | codebase | |
| | callback | |<------| | notify   | |
| | notify   | |------>| | callback | |
|  ----------  |       |  ----------  |
 --------------         --------------

</pre>
<i>Note:</i> Each outgoing TCP link consumes a corresponding anonymous
return link, so the following port consumption realities must be considered:
<ul>
<li>The item consumes 2 inbound ports permanently (http/callback)
<li>The item consumes 1 outbound short-term port per client (http)
<li>The item consumes 2 outbound session-term ports per client (notify/callback)
</ul>
Therefore, it should be understood that since each connecting client
will consume 2 dynamically allocated TCP ports, theoretically, no more
than 32k simultaneous clients could be served by one address, assuming the
address had no other servers.  Therefore, for very high usage sites, multiple
physical machines, or a multi-homed host, would become necessary.</body>
