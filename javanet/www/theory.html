<html>
   <head>
      <title>The CaJo Project</title>
      <meta name="Keywords" content="cajo, rmi, java, distributed computing, Transparent Distributed Computing">
      <meta name="Description" content="Cajo Distributed Application Framework">
      <meta name="Author" content="John Catherino">
   </head>
   <body>
      <div id="projecthome" class="app">
      <table width="100%" align=center>
         <tr>
            <td>

<!-- begin main.html -->

                        <center>
                           <a href="index.html" title="cajo home page"><b>Welcome</b></a> |
                           <a href="tutorial.html" title="getting started"><b>Tutorial</b></a> |
                           <b>Theory</b> | 
                           <a href="gotcha.html" title="important details"><b>Gotchas</b></a> |
                           <a href="faq.html" title="common questions"><b>FAQ</b></a> |
                           <a href="acknowlege.html" title="supporters of the marque"><b>Acknowledgments</b></a> |
                           <a href="license.html" title="what's the LGPL"><b>License</b></a> |
                           <a href="docs/overview-summary.html" title="package documentation"><b>Javadocs</b></a> <br><br>
                        </center>
                        <center>
                           <a href="item.html" title="Remote object"><b>Item</b></a> |
                           <a href="proxy.html" title="interface object"><b>Proxy</b></a> |
                           <a href="multicast.html" title="broadcast object"><b>Multicast</b></a> |
                           <a href="client.html" title="host object"><b>Client</b></a> |
                           <a href="server.html" title="application server"><b>CodebaseServer</b></a> |
                           <a href="example.html" title="demo objects"><b>Example</b></a> |
                           <a href="overview.html" title="adding to existing applications"><b>Overview</b></a><br><br>
                        </center>

                           <font size="4">
                              <b>Inside the cajo framework.</b><br>
                           </font>

                           <h3>Introduction</h3><br>

                           Every remotely accessible object in the framework is known as an
                           <a href=item.html>Item</a>. An application can host one or more items
                           within its Virtual Machine. Items can call other items, and an item can
                           also be called by other items. A special type of item is known as a
                           <a href=proxy.html>Proxy</a>. Proxies are items sent from one virtual
                           machine, to execute in the context of another. Proxies can also call, or
                           be called, by other items, and even by other proxies.<br><br>

                           In the standard RMI framework, each remote object must have a unique
                           <i>"stub"</i> compiled for its callable methods. This can quickly become
                           burdensome, especially if the interaction between objects becomes highly
                           diverse; and is completely impossible when method signatures are unknown
                           at compile time. To address these issues, the framework defines only one
                           functional interface; every item inherits the
                           <a href=docs/gnu/cajo/invoke/Invoke.html>Invoke</a> interface. It defines
                           a single method, to represent all object methods; it accepts a method name,
                           the arguments to be provided to it, and the data to be returned; i.e.:

                           <pre>   Object invoke(String method, Object args);</pre>

                           </a><i>Note:</i> this mechanism operates slightly differently
                           from standard Java method invocation in two distinct ways.  First the
                           return type must be of type Object or a derived type.  This means an
                           invocation cannot return a primitive type, such as <tt>int</tt> or
                           <tt>char</tt>. Second, the argument type must also be of type Object,
                           meaning it too cannot be a primitive type. However, just as with conventional
                           invocations, both the argument and the return can be of type Object[]
                           indicating multiple objects are being transferred, or they can be null
                           indicating no object transfer. Also, it is <i>highly</i> recommended that
                           rather than using the invoke interface directly, always interact with a
                           remote reference using the static invoke method of the
                           <a href=docs/gnu/cajo/invoke/Remote.html>Remote</a> class.  It has the
                           following signature:

                           <pre>   Object Remote.invoke(Object object, String method, Object args);</pre>

                           It provides all the functionality of the invoke interface, but also works on
                           <u>both</u> remote objects, and ordinary local objects. This can allow code
                           to transparently scale from local to remote object use, even at runtime, with
                           no application source code changes.
                           
                           <h3>Remoting Items</h3><br>

                           The invocation of a method on a remote object using the Invoke interface is
                           made possible using the Remote class.  It combines Java RMI with another
                           Java feature known as <i>reflection</i>.  The Remote class takes <i>any</i>
                           object, and places a remotely invokable wrapper around it. When remote
                           objects execute the invoke method, Remote uses reflection to find the method
                           on its internal object, matching both the name and the argument types. If it
                           is found, it executes that method, and returns the result, if any.  If no
                           matching method can be found on the internal object, a
                           <tt>NoSuchMethodException</tt> is thrown. This technique effectively
                           makes all public methods of the internal object remotely callable;
                           except those using primitive types, such as int and char, in arguments,
                           or as returns.

                           <h3>Mobile Code</h3><br>

                           An item can send mobile code, i.e. proxy items and complex object arguments
                           to clients using the <a href=docs/gnu/cajo/utils/CodebaseServer.html>CodebaseServer</a>
                           class.  CodebaseServer will create a specialized http server on the
                           designated TCP port. It serves the specified jar file containing the class
                           files needed by the client, along with any other resources needed by the
                           proxies. The resources are typically, images and string tables.  By default,
                           a client VM <u>will not</u> accept mobile code. This is typically enabled by
                           calling the
                           <a href=docs/gnu/cajo/utils/ItemServer.html#acceptProxies()>acceptProxies</a>
                           method of the
                           <a href=docs/gnu/cajo/utils/ItemServer.html>ItemServer</a> class.  This
                           will install an RMISecurityManager to accept the code, and protect the
                           client hardware and files, it effectively creates an applet-like sandbox
                           around the incoming code.  In essence, <i>mobile code</i> means the
                           client's VM is using classes from a codebase provided to it by the server,
                           over the network.

                           <h3>Obtaining References</h3><br>

                           References to remote items can be easily passed to other items,
                           as a method argument, or return. They can even be written to disc, and
                           read back for use at some later time. However, obtaining initial references
                           is done via two standard mechanisms:<br><br>

                           First, it is generally useful to
                           <a href=docs/gnu/cajo/utils/ItemServer.html#bind(java.lang.Object,%20java.lang.String)>bind</a>
                           each item with the ItemServer class. ItemServer will automatically create
                           an rmiregistry, and bind the item under the name provided. Other clients can
                           now contact the registry, and obtain a remote reference to the item by name.
                           The rmiregistry, and the item communicate using the same TCP port. Therefore,
                           all that is required for a client to obtain a reference to an item using this
                           mechanism is the server host name, port number, and the name under which the
                           item is bound. Cannonically, the default item for any server is bound under
                           the name "<i>main</i>". Obtaining a reference to a bound remote item
                           is accomplished using the static
                           <a href=docs/gnu/cajo/invoke/Remote.html#getItem(java.lang.String)>getItem</a>
                           method of the Remote class. This mechanism is called linking
                           <i>statically</i>. <br><br>

                           The second mechanism to obtain a reference to a remote item is using the
                           <a href=docs/gnu/cajo/utils/Multicast.html>Multicast</a> class. Unlike the
                           previous method which uses TCP/IP to obtain the reference, this technique
                           uses UDP/IP.  Instead of needing to know the server's TCP address and port
                           number, the client needs to know the UDP address and port number the server
                           will be using. The difference is that servers can pick their UDP addresses,
                           and they are independent of their TCP address. Also, a server can use
                           multiple multiple UDP addresses if needed. Multiple servers will share the
                           same address, to form <i>groups</i>. A server <i>broadcasts</i> a remote
                           reference to an item by calling the
                           <a href=docs/gnu/cajo/utils/Multicast.html#announce(java.lang.Object,%20int)>announce</a>
                           method of Multicast.  This will send the reference to all clients listening
                           in the <i>group</i>. Items listen for these announcements using the
                           <a href=docs/gnu/cajo/utils/Multicast.html#listen(java.lang.Object)>listen</a>
                           method of Multicast. Use of UDP/IP, and multicasting, has proven to be
                           unfamiliar to a lot of developers, so an entire tutorial
                           <a href=multicast.html>page</a> has been dedicated to the use of the
                           Multicast class. This mechanism allows items to spontaneously form
                           networks of functionality by linking <i>dynamically</i>.

                           <h3>Conclusion</h3><br>

                           Essentially, any Java application is but a collection of objects, used by a
                           virtual machine, to accomplish a specific purpose. This framework
                           transparently provides developers the object resources of other remote
                           virtual machines, with which to create applications.<br><br>

                           For example; the paradigm could be represented graphically, something like
                           this:

                           <center><img src=images/graph.gif></center>

                           Here we see that local objects can directly interact with other local
                           objects, even with local objects that are also remotely accessible by
                           other virtual machines. Additionally, they can interact with remote
                           objects of other virtual machines. They can even interact with proxy
                           objects, loaded into their virtual machine, typically from other virtual
                           machines, whose class definitions, if unknown to the client, would be
                           provided by codebase servers. They can even interact with remote proxy
                           objects. Proxies have the same connection options as local objects. In fact,
                           every type of object can freely interact with any other type of object, even
                           across virtual machine boundaries, with the exception of
                           local-to-local.<br><br>

                           Now relax; this has been a lot of material, presented in a <i>very</i> short
                           time. Trust me, it took me <u>much</u> longer to come up with this, than to
                           explain it. So now take a break, do something else, let it soak in. Soon a
                           profound <i>breakthrough</i> will occur; then, let me be the first to welcome
                           you to: The World Wide Virtual Machine!  :-)<br><br>

                           <div align="center">
                              <font size="-2">
                                 <hr width="80%">
                                 All objects are <u>local</u>: machine boundaries, whether virtual or
                                 physical, are merely conceptual.
                              </font>
                           </div>
<!-- end main.html -->

            </td>
         </tr>
      </table>
   </body>
</html>
