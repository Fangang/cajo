<html>
   <head>
      <title>The CaJo Project</title>
      <meta name="Keywords" content="cajo, rmi, java, distributed computing, Transparent Distributed Computing">
      <meta name="Description" content="Cajo Distributed Application Framework">
      <meta name="Author" content="John Catherino">
   </head>
   <body>
      <div id="projecthome" class="app">
      <table width="100%" align="center">
         <tr>
            <td>

<!-- begin main.html -->

                        <center>
                           <a href="index.html" title="cajo home page"><b>Welcome</b></a> |
                           <a href="tutorial.html" title="getting started"><b>Tutorial</b></a> |
                           <a href="theory.html" title="how it all works"><b>Theory</b></a> | 
                           <a href="gotcha.html" title="important details"><b>Gotchas</b></a> |
                           <a href="faq.html" title="common questions"><b>FAQ</b></a> |
                           <a href="acknowlege.html" title="supporters of the marque"><b>Acknowledgments</b></a> |
                           <a href="license.html" title="what's the LGPL"><b>License</b></a> |
                           <a href="docs/overview-summary.html" title="package documentation"><b>Javadocs</b></a> <br><br>
                        </center>
                        <center>
                           <a href="item.html" title="Remote object"><b>Item</b></a> |
                           <a href="proxy.html" title="interface object"><b>Proxy</b></a> |
                           <a href="multicast.html" title="broadcast object"><b>Multicast</b></a> |
                           <a href="client.html" title="host object"><b>Client</b></a> |
                           <a href="server.html" title="application server"><b>CodebaseServer</b></a> |
                           <b>Example</b> |
                           <a href="overview.html" title="adding to existing applications"><b>Overview</b></a><br><br>
                        </center>

                           <font size="4">
                              <b>Demonstrating the cajo framework's features and functions.</b>
                           </font><br><br>

                           The example package is a collection of four small classes demonstrating the
                           use of the framework.  It uses all the classes of the framework, except
                           one, and that one will be described at the <a href="#Conclusion">conclusion</a>
                           of the document, as well as why it was not part of the example.<br><br>
                           The four example classes are as follows:<br><br>

                           <table>
                              <tr>
                                 <td><a href="#TestItem">TestItem</a></td>
                                 <td>An introductory server item</td>
                              </tr>
                              <tr>
                                 <td><a href="#TestProxy">TestProxy</a></td>
                                 <td>An introductory server item proxy</td>
                              </tr>
                              <tr>
                                 <td><a href="#Builder">Builder</a></td>
                                 <td>Configure and serialize the example proxy</td>
                              </tr>
                              <tr>
                                 <td><a href="#Main">Main</a></td>
                                 <td>To launch the example server application</td>
                              </tr>
                           </table><br>

                           As mentioned in the <a href=proxy.html>proxy</a> page, a server does not
                           need to use proxies; one is included in the example, for completeness of
                           illustration.

                           <a id="TestItem"></a><h3>Test Item</h3><br>

                           The TestItem class demonstrates the basic functionality of a server item. A
                           server item has two primary components; a processing thread, and a callable
                           interface.  While the processing thread is technically optional, a callable
                           interface is logically essential. The processing thread, if defined, is
                           launched automatically, following binding of the object with the
                           <a href=docs/gnu/cajo/utils/ItemServer.html>ItemServer</a>. A server item can
                           also be purely <i>event driven</i>; i.e. only executing when its callable
                           methods are being invoked; in this case it would not define a
                           <a href=docs/gnu/cajo/utils/BaseItem.MainThread.html>MainThread</a> object. The
                           callable interface to an item is simply its collection of publicly declared
                           methods. (subject to the minor restrictions outlined in the
                           <a href="theory.html#rules">theory</a> page)<br><br>

                           The thread in the example item performs the <i>highly recommended</i>
                           practice of looping on its <code>thread.isInterrupted()</code> method. The
                           item itself, or other parts of the application, can invoke a
                           <code>thread.interrupt()</code> on the public thread member.  This does
                           <b>not</b> terminate the thread automatically, rather only flags it. This
                           allows item's processing thread a mechanism to perform a safe and orderly
                           shutdown.  This is generally done when taking a server item offline. This
                           technique has the added benefit that if the item's thread is waiting, it
                           will wake it up, via the throwing of an <code>InterruptedException</code><br><br>

                           Since this is only an example item implementation, the main processing thread
                           has basically nothing to do.  So it simply puts itself to sleep, to be awoken
                           should something interesting happen.  When awoken, it sleeps for 500
                           milliseconds, to <i>appear</i> that it is doing something.  Following that,
                           it invokes the method "callback" on an item reference it gets from
                           <i>somewhere</i>, (actually one of its own methods, described next) passing a
                           string argument, and displaying the result.  It then loops back up into sleep.
                           That's all it does, until interrupted, if ever.<br><br>

                           The interesting part happens in its public callback method.  It is
                           appropriately named, though it actually could be named anything.  When it is
                           invoked, it saves the reference to the presumably remote calling item, and
                           wakes its main thread, to operate as described in the previous paragraph. It
                           then prints the message provided by the invoking item, and returns a string
                           indicating synchronous acknowlegement. Again, the critical point is; every
                           public method an item declares will be invokable from remote items, no
                           differently than if it was being interfaced  by local objects. <i>Note:</i>
                           this implementation also intentionally illustrates the importance of
                           reentrancy consideration with regard to an item's public interface. If many
                           items invoke this method simultaneously, only the last caller will get called
                           back by the item's main thread.  Making the example's callback method
                           threadsafe is left as a mental excercise for the reader.<br><br>

                           Lastly, the item implements the <code>toString</code> method, inherited from
                           <code>Object</code>.  This is also a <i>highly recommended</i> practice.  In
                           this case, it is used when monitoring the item, which is covered in the
                           upcoming section on <a href="#Main">Main</a>, and also greatly aids in
                           debugging. Being public, note that the method is also remotely callable, to
                           identify the object at the other end of the remote reference.  That's all
                           there is to the TestItem example.

                           <a id="TestProxy"></a><h3>Test Proxy</h3><br>

                           The TestProxy class is a small proxy item illustrating many features of the
                           framework.  It is sent to a client, as the return from the TestItem's
                           <a href=docs/gnu/cajo/utils/BaseItem.html#getProxy()>getProxy</a> method,
                           inherited from
                           <a href=docs/gnu/cajo/utils/BaseItem.html>BaseItem</a>. The proxy
                           automatically inherits a remote reference to the TestItem.  On arrival at
                           the client, it is initialized (by the client) with the assignment of its
                           remoteThis member with a reference to the proxy itself, remoted the context
                           of the client VM.  This initialization, will cause the proxy's main
                           thread to start, if it has one. As with server items; a proxy need not
                           define a main thread, i.e. it can also be purely <i>event driven</i>.<br><br>

                           The example demonstrates the Internationalization feature of proxies.
                           When the proxy is initialized, it will load its string table, if defined,
                           from a properties file, most closely matching the locale of the receiving VM.
                           This allows the proxy's user interface to be in German on an Austrian machine,
                           and Spanish on a Mexican one, for example.  Of course, all of these
                           translated string tables must be provided.  The properties file, and all
                           other non-class resources are generally placed in a support directory.  In
                           this case it is called include. The reason for the separate directory, is to
                           simplify the proxy's jar creation, as the build script can then include all
                           the files in the directory blindly.<br><br>

                           Since this is a graphical proxy example, it's initialization invocation also
                           returns a non-null graphical component that the client can display on its
                           monitor. The purpose of the component is to provide a graphical user
                           interface to a remote server item, however offloading as much processing as
                           necessary, to the client's runtime.<br><br>

                           When the proxy's processing thread starts, it writes out an arrival notice
                           to the client's user interface.  Next, it invokes the method named callback
                           on the reference to its server item.  It passes its remote reference to
                           itself, and a message string.  It displays the value returned  by the
                           invocation as well.  Following that, it exits its run method, causing its
                           main processing thread to terminate.<br><br>

                           The proxy has a public method named callback. When called, in this case by
                           the TestProxy, it will display the incoming text argument, and send back a
                           synchronous text acknowlegement of its own. Just as with server items, all
                           of a proxy's public methods, can be called by remote items, or proxies,
                           having a reference to the proxy.

                           <a id="Builder"></a><h3>Builder</h3><br>

                           The Builder class serves two purposes:<br><br>

                           First it serves to replace all the code which would otherwise go into the
                           proxy's constructor.  Why do this? Because all of the construction code,
                           which can be quite sizeable if the proxy is elaborate, can be left out of
                           the proxy's jar file.  This reduces the proxy jar size, and also adds the
                           additional security that the proxy becomes much more difficult to
                           <i>reverse-engineer</i>, if such protection is important to you.<br><br>

                           The second function of the Builder class is to instantiate the proxy, then
                           serialize its image to disc.  This serialized object will be included in the
                           proxy jar file, and referenced through a
                           <a href=docs/gnu/cajo/utils/ProxyLoader.html>ProxyLoader</a> in the TestItem's
                           runtime.  This is the <i>most elaborate</i> way to use a ProxyLoader. They can
                           also be used to invoke a proxy's no-arg constructor, to create a new instance
                           of the proxy, on its arrival at the host VM. In that case, all of the
                           construction code would have to be passed to the client VM. Use of a
                           ProxyLoader is optional, but it is a <i>highly recommended</i> optimization
                           as it prevents having to load full proxies into the server item runtime.<br><br>

                           The actual mechanics of what is going on inside the builder is not so
                           important.  It is basically configuring graphical components, and putting
                           them into the graphical user interface member object
                           <a href=docs/gnu/cajo/utils/BaseProxy.html#container>container</a>.
                           The proxy will return this graphical container to the hosting client as a
                           result of its initialization invocation.  It also defines the keys of the
                           string table, also loaded during initialization. It references a ProxyLoader,
                           this is a special requirement.  The proxy will need to use the ProxyLoader
                           class file on its arrival at the host, however, it doesn't need to use one at
                           compile time.  Without this apparently unused reference, the proxy would
                           suffer a <code>ClassNotFoundException</code> at the host, as ProxyLoader class
                           would not be in the proxy jar file, as it would have not been compiled.

                           <a id="Main"></a><h3>Main</h3><br>

                           The Main class illustrates how to make a server application.  A server is
                           simply an application which makes one or more items available for remote
                           invocation. The Main class first configures its network settings, then makes
                           the test item accessible.  As explained in the
                           <a href=tutorial.html#launching>launching</a> turorial, the application can
                           take up to five parameters, in order, from most likely to need changing, to
                           least likely, and where order and precedence matters. The network
                           configuration parameters are as follows:

                           <ul>
                              <li> the port number on which to serve the proxy's codebase <br>(default = 80)
                              <li> the port number on which to communicate with the item <br>(default = 1099)
                              <li> the external server name or address, if using NAT <br>(default = same as local)
                              <li> the local host network interface, if multiple <br>(default = primary NIC)
                              <li> the outside port number to communicate with the item <br>(default = same as local)
                           </ul>

                           The server also does a few additional actions, to illustrate the operation of
                           remaining parts of the framework.  It multicasts a remote reference to itself
                           to announce its startup.  It uses a
                           <a href=docs/gnu/cajo/utils/MonitorItem.html>MonitorItem</a>, to log data
                           about the remote invocations to its item to the system console.  It even
                           listens for other item announcements; sending the announcers a remote
                           reference the test proxy, invoked on their setProxy method, if they have one.
                           Finally it finishes up by listing its configuration information.  This can be
                           useful if the server is told to use any anonymous TCP ports (i.e. port = 0),
                           the info will contain the actual port numbers chosen by the operating system
                           at startup.

                           <h3>Conclusion</h3><br>
                           
                           <a id="Conclusion"></a>The <a href=docs/gnu/cajo/utils/ZippedProxy.html>
                           ZippedProxy</a> class is the only utility class not used in the example.
                           This is bacause the example demonstrates indirectly referencing a proxy, by
                           the serving item.  This is indicated when the server item, does not need to
                           configure a proxy before sending it.  This can save a lot of space in the
                           server item's runtime, especially if the proxy is very large, or if a
                           single VM is serving many proxies.<br><br>

                           In cases, when a proxy <u>must</u> be loaded into the server's VM; presumably
                           for some runtime dependent configuration, it is <i>highly recommended</i>
                           to use a ZippedProxy.  It compresses the serialized image of the proxy as it
                           is sent to the hosting VM. This is done to reduce the amount of data, and
                           transmission time, required to send the proxy.  If the proxy image is large,
                           the network uplink is slow, or the cost per byte sent is high, this technique
                           makes tremendous sense.  Its use is recommended for <u>all</u> proxies loaded
                           into the server, as a general paradigm.<br><br>

                           <br>
                           <div align="center">
                              <font size="-2">
                                 <hr width="80%">
                                 Once you understand the basics; the advances begin to emerge.
                              </font>
                           </div>

<!-- end main.html -->

            </td>
         </tr>
      </table>
   </body>
</html>
