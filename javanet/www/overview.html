<html>
   <head>
      <title>The CaJo Project</title>
      <meta name="Keywords" content="cajo, rmi, java, distributed computing, Transparent Distributed Computing">
      <meta name="Description" content="Cajo Distributed Application Framework">
      <meta name="Author" content="John Catherino">
   </head>
   <body>
      <div id="projecthome" class="app">
      <table width="100%" align="center">
         <tr>
            <td>

<!-- begin main.html -->

                           <font size="4">
                              <b>Adding cajo to existing applications...</b><br><br>
                           </font>

It is very easy to incorporate the cajo framework into existing applications.
Hopefully this overview will simplify the process. As you will see very
shortly; making <i>any</i> object remotely accessible, can be done with as
little as <u>one</u> additional line of code!<br><br>

Let us start with a trivial example object:<br>

<tt><pre>public class SomeObject {
   protected String string;
   protected Integer stuff;
   public String foo() { return string; }
   public void bar(String string, Integer stuff) {
      this.string = string;
      this.stuff = stuff;
   }
   public String baz(String string) {
      try { return this.string; }
      finally { this.string = string; } // fun (:
   }
}</pre></tt>

One of the most important aspects of the cajo framework is that it does not
require any changes to <i>your</i> objects, in order to use them
remotely. Even if your application is already using another distributed
object framework; it is very easy to <i>drop in</i> cajo support, and
increase your distributed user base. To make an object remotely accessible,
the framework provides <u>two</u> distinct options; these are known
collectively as <i>static</i>, and <i>dynamic</i> binding. Even <u>both</u>
may be used on the <i>same</i> object.<br><br>

Static binding is accomplished simply via a call to the static
<a href=docs/gnu/cajo/utils/ItemServer.html#bind(java.lang.Object,%20java.lang.String)>
bind</a> method, of the <a href=docs/gnu/cajo/utils/ItemServer.html>
ItemServer</a> class. This type of binding will require the client to know
the address of the server, in order to obtain a reference to the object.
Clients statically bind to a remote object using the static <a href=docs/gnu/cajo/invoke/Remote.html#getItem(java.lang.String)>
getItem</a> method of the <a href=docs/gnu/cajo/invoke/Remote.html>Remote</a>
class.<br><br>

It would look something like this:

<tt><pre>
   Itemserver.bind(someObject, "someName");

   Object someObject = Remote.getItem("//serverName/someName");
</pre></tt>

Dynamic binding is accomplished simply via a call to the static <a href=docs/gnu/cajo/utils/Multicast.html#announce(java.lang.Object,%20int)>
announce</a> method, of the <a href=docs/gnu/cajo/utils/Multicast.html>
Multicast</a> class. This will <i>'broadcast'</i> the remote object reference
to <u>all</u> listening Virtual Machines. Clients dynamically bind to a
remote objects using the static <a href=docs/gnu/cajo/utils/Multicast.html#listen(java.lang.Object)>
listen</a> method of the Multicast class.<br><br>

It would look something like this:

<tt><pre>
   Multicast.announce(someObject, 16);

   Multicast.listen(someListener);
</pre></tt>

In either case; once a remote reference to an object is obtained, it can be
used to invoke its public methods. The reference can also be passed to other
objects, including remote ones; as either an argument, or a return. It could
<i>even</i> be thrown in an Exception. Any object receiving this reference,
can <i>also</i> invoke its remote methods. The reference can even be written
to a file; using the static <a href=docs/gnu/cajo/invoke/Remote.html#zedmob(java.io.OutputStream,%20java.lang.Object)>
zedmob</a> method of the Remote class, for later use, even by <i>another</i>
program.  The key to all this power; is the static <a href=docs/gnu/cajo/invoke/Remote.html#invoke(java.lang.Object,%20java.lang.String,%20java.lang.Object)>
invoke</a> method, of the Remote class.<br><br>

Invoke is the cajo architecture approach to dynamic method invocation,
supplemented by use of Java reflection. It is a foundation of the
framework. It can be used to invoke <i>any</i> public method, on <i>any</i>
object; including <u>local</u> objects.<br><br>

The method has the following signature:

<code><pre>  Object Remote.invoke(Object object, String method, Object args) throws Exception;</pre></code>

The <tt>object</tt> argument is the object on which to be operated. The
<tt>method</tt> argument is the name of the public method to be invoked.
The <tt>args</tt> argument represents the argument(s) to be provided to the
method; if any. Multiple arguments are represented when <tt>args</tt> is an
Object array. A null <tt>args</tt> value indicates no arguments. The method's
result is the object returned from the method invocation, if any. The method
declares that it throws <tt>Exception</tt>, to allow the called method the
freedom to throw any type of Exception; including none at all. It is
<i>also</i> used to cover network related failures, for invocations on remote
objects.<br><br>

It might appear that all typesafety has been completely abandoned; looking
somewhat like a return to the C language. However, what has <i>really</i>
happened is that strong typechecking has moved, necessarily from compile
time, to runtime. There is however, a <u>very</u> useful technique, to
restore compile time typechecking; it is called a <a href=docs/gnu/cajo/utils/extra/Wrapper.html>
wrapper</a> class.<br><br>

If a client already knows the interface to a remote object; it could define
a wrapper class, to take the remote reference, and provide a compile time
typesafe interface to it.<br><br>

Wrapping our previous example:<br>

<tt><pre>public class WrapperObject {
   protected Object obj;
   public WrapperObject() {
      // obj = new SomeObject(); // when local, or...

      try { obj = Remote.getItem("//serverName/someName"); }
      catch(Exception x) { /* remote object not available */ }
   }
   public String foo() {
      try { return (String)Remote.invoke(obj, "foo", null); }
      catch(Exception x) { /* invocation failure */ }
   }
   public void bar(String string, Integer stuff) {
      try { Remote.invoke(obj, "bar", new Object[] { string, stuff }); }
      catch(Exception x) { /* invocation failure */ }
   }
   public String baz(String string) {
      try { return (String)Remote.invoke(obj, "baz", string); }
      catch(Exception x) { /* invocation failure */ }
   }
}</pre></tt>

It is very important to remember that since the <tt>Remote.invoke</tt>
method works on <i>both</i>, local <u>and</u> remote objects; the wrapper
paradigm provides the ability to <i>transparently</i> scale; from local
object interaction, to remote, <u>without</u> affecting the remaining source
code. It provides the <u>ultimate</u> flexibility: The wrapped object can
easily be changed, from local to remote, even to a different server;
<i>at</i> runtime!<br><br>

                           <div align="center">
                              <font size="-2">
                                 <hr width="80%">
                                 The cajo framework doesn't dictate your architecture: It simply drops in!
                              </font>
                           </div>
<!-- end main.html -->

            </td>
         </tr>
      </table>
   </body>
</html>
