<html>
   <head>
      <title>The CaJo Project</title>
      <meta name="Keywords" content="cajo, rmi, java, distributed computing, Transparent Distributed Computing">
      <meta name="Description" content="Cajo Distributed Application Framework">
      <meta name="Author" content="John Catherino">
   </head>
   <body>
      <div id="projecthome" class="app">
      <table width="100%" align="center">
         <tr>
            <td>

<!-- begin main.html -->

                        <center>
                           <a href="index.html" title="cajo home page"><b>Welcome</b></a> |
                           <a href="tutorial.html" title="getting started"><b>Tutorial</b></a> |
                           <a href="theory.html" title="how it all works"><b>Theory</b></a> | 
                           <a href="gotcha.html" title="important details"><b>Gotchas</b></a> |
                           <a href="faq.html" title="common questions"><b>FAQ</b></a> |
                           <a href="acknowlege.html" title="supporters of the marque"><b>Acknowledgments</b></a> |
                           <a href="license.html" title="what's the LGPL"><b>License</b></a> |
                           <a href="docs/overview-summary.html" title="package documentation"><b>Javadocs</b></a><br><br>
                        </center>
                        <center>
                           <b>Item</b> |
                           <a href="proxy.html" title="interface object"><b>Proxy</b></a> |
                           <a href="multicast.html" title="broadcast object"><b>Multicast</b></a> |
                           <a href="client.html" title="host object"><b>Client</b></a> |
                           <a href="server.html" title="application server"><b>CodebaseServer</b></a> |
                           <a href="example.html" title="demo objects"><b>Example</b></a><br><br>
                        </center>

                           <font size="4">
                              <b>Server items are the core of the cajo framework.</b>
                           </font><br><br>

                           A server is a Java Virtual Machine that makes one or more of its objects
                           remotely accessible.  A remotely accessible object is called an <b>item</b>
                           in terms of this framework. Items often derive from the class
                           <a href= docs/gnu/cajo/utils/BaseItem.html>BaseItem</a>, though they can
                           actually be <u>any</u> object. Remotely accessible items are created from
                           objects using the <a href=docs/gnu/cajo/invoke/Remote.html>Remote</a> class.
                           Remote takes the item object in its constructor, and finally implements the
                           <a href=docs/gnu/cajo/invoke/Invoke.html>Invoke</a> interface, which serves
                           to make the item object's public methods remotely callable. The Invoke
                           interface defines a single method:

                              <pre><code>   Object invoke(String method, Object args);</code></pre>

                           Remote objects call the invoke method, passing it a method name, and an
                           argument that can either be an object, and object array, or null.  The
                           invoke implementation of the Remote class uses a Java technique called
                           <i>reflection</i> whereby it finds the public method of its member object
                           matching the name provided in the remote call, accepting arguments
                           of the type, and in the order, provided by the caller.  If there is a match,
                           it will invoke that method on the item, and return the result if any. If no
                           matching method can be found however, in method name <u>and</u> argument
                           order, the invocation will result in a <code>NoSuchMethodException</code>
                           being thrown at the caller.<br><br>

                           Item objects are free to implement any public, in this case meaning remotely
                           callable, methods of any type. The only requirement is that the calling
                           object from a different machine, virtual or physical, must know the item's
                           method signature. This is no different than for conventional objects with
                           two exceptions. First there is no compiletime type checking. Second, due to
                           a restriction in the Java reflection mechanism; primitive types such as
                           <code>int</code> or <code>char</code> for example, cannot be sent as
                           arguments, or returned, rather they must be sent using their object
                           representations, in this case <code>Integer</code> or <code>Character</code>.
                           This means all argument and return typechecking will be done at runtime
                           instead of compiletime.

                           <h3>Deploying items</h3><br>

                           An object can be made available for remote access in either of two ways.
                           First the object can be passed to the
                           <a href=docs/gnu/cajo/utils/ItemServer.html#bind(java.lang.Object,%20java.lang.String)>
                           bind</a> method of the
                           <a href=docs/gnu/cajo/utils/ItemServer.html>ItemServer</a> class, along
                           with a name, by which it may be referenced. This allows remote machines to
                           <i>fetch</i> the reference using the
                           <a href=docs/gnu/cajo/invoke/Remote.html#getItem(java.lang.String)>getItem</a>
                           method of <a href=docs/gnu/cajo/invoke/Remote.html>Remote</a>,  providing the
                           host name, and item name. This is called <i>static</i> linking in the context
                           of this framework.<br><br>

                           The second method to obtain remote methods is by broadcasting the reference
                           to all listening VMs. This technique is covered in the <a href=multicast.html>
                           multicast</a> section. For now, think of it as a way to <i>send</i> a
                           reference to an object to remote VMs. This is known as <i>dynamic</i> linking,
                           in the context of this framework.

                           <h3>Using items</h3><br>

                           All invocations on any service object should be made using the Remote.invoke
                           method.  While technically this technique isn't necessary when the item is
                           local, i.e. in the same Virtual Machine, it allows the called object to be
                           moved to a another machine, whether virtual or physical, with <u><b>no</b></u>
                           source code changes! A <i>highly recommended</i> design pattern is to simply
                           place a wrapper object around the item reference, where its traditional
                           methods simply pass the invocation onto the internal item reference.<br><br>

                           Consider for example:
<code><pre>
   // assume member Object foo either local or remote...

   String toString() {
      // no arguments, object return ...
      return (String)Remote.invoke(foo, "toString", null);
   }
   boolean equals(Object o) {
      // single argument, primitive return...
      return ((Boolean)Remote.invoke(foo, "equals", o)).booleanValue());
   }
   void someMethod(String a, String b, String c) {
      // multiple arguments, no return...
      Remote.invoke(foo, "someMethod", new Object[] { a, b, c });
   }
</pre></code>
                           Object construction can be abstracted similarly:
<code><pre>
   void construct() {
      // when the object is local:
      foo = new Foo(...);
   }
   void construct() {
      // when the item is remote:
      foo = Remote.getItem("//myhost.com/foo");
   }
   void construct() {
      // when the item is a zedmob on disc:
      foo = Remote.getItem("/beans/foo.ser");
   }
</pre></code>

                           Note: changing foo from local to remote will have no effect on the syntax of
                           the remaining source code.

                           <h3>Remote Transparency</h3><br>

                           By handling objects using the Remote.invoke method, calling objects need not
                           know or even care, if the objects are local or remote. However, should it be
                           important to know the remoteness or locality of an object; it can be tested
                           in the following way:
<code><pre>
   if (foo instanceof RemoteInvoke) {
      // foo is a remote object ...
   } else {
      // foo is a local object ...
   }
</pre></code>
                           This is the sole purpose of the
                           <a href=docs/gnu/cajo/invoke/RemoteInvoke.html>RemoteInvoke</a> interface,
                           testing locality, as it is otherwise a bodyless interface.

                           <h3>Base Items</h3><br>

                           A BaseItem can optionally define a
                           <a href= docs/gnu/cajo/utils/BaseItem.MainThread.html>MainThread</a> object,
                           which would be started automatically by the ItemServer, the on binding of the
                           item. This allows an item to perform default processing, independently of its
                           other invocation threads. Its main thread instance can be accessed via its
                           public member named <a href=docs/gnu/cajo/utils/BaseItem.html#thread>thread</a>,
                           on which it can be interrupted. In fact, the item's run method should
                           periodically monitor, to check if the thread <code>isInterrupted()</code>,
                           and perform an orderly shutdown. An item can optionally have no main thread.
                           This would be known as an <i>event-driven</i> item, meaning it executes only
                           when called by a client. <i>Note:</i> having multiple clients can cause an
                           Item's public methods to be invoked reentrantly.

                           <h3>Conclusion</h3><br>

                           Ultimately that's all there is to an item. To make an item reference
                           <u>statically</u> accessible to other virtual machines, it is passed to the
                           <a href=docs/gnu/cajo/utils/ItemServer>ItemServer</a> static
                           method
                           <a href=docs/gnu/cajo/utils/ItemServer.html#bind(java.lang.Object,%20java.lang.String,%20boolean,%20gnu.cajo.utils.Multicast)>bind</a>.
                           A client application can obtain a reference to a remote item using the
                           ItemServer static method
                           <a href=docs/gnu/cajo/invoke/Remote.html#getItem(java.lang.String)>getItem</a>;
                           requesting the item by name. As a <i>de facto</i> convention, the primary
                           item served by a VM is bound under the name <i>"main"</i>. Item
                           references can also be made <u>dynamically</u> accessible using the
                           <a href=multicast.html>Multicast</a> class. Client applications can obtain
                           references to remote items using the Multicast method
                           <a href=docs/gnu/cajo/utils/Multicast.html#listen(gnu.cajo.invoke.Invoke)>listen</a>.
                           A virtual machine can remote as many items as it needs.<br><br>

                           In the next section, see how an item can use a <a href=proxy.html>proxy</a>
                           item to send some, or a majority of its functionality, and even an optional
                           graphical user interface, to a client.<br><br>
                           
                           <div align="center">
                              <font size="-2">
                                 <hr width="80%">
                                 Items are just objects, which can be also invoked by other (remote) objects.
                              </font>
                           </div>

<!-- end main.html -->

                     </td>
                  </tr>
               </table>
            </td>
         </tr>
      </table>
   </body>
</html>
