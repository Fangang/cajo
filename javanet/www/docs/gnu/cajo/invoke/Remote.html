<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Thu Aug 11 18:33:53 EDT 2005 -->
<TITLE>
Remote (Cajo Distributed Component Architecture)
</TITLE>

<META NAME="keywords" CONTENT="gnu.cajo.invoke.Remote class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Remote (Cajo Distributed Component Architecture)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../gnu/cajo/invoke/NoSecurityManager.html" title="class in gnu.cajo.invoke"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Remote.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
gnu.cajo.invoke</FONT>
<BR>
Class Remote</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by">java.rmi.server.RemoteObject
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by">java.rmi.server.RemoteServer
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by">java.rmi.server.UnicastRemoteObject
              <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>gnu.cajo.invoke.Remote</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke">Invoke</A>, java.rmi.Remote, <A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke">RemoteInvoke</A>, java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public final class <B>Remote</B><DT>extends java.rmi.server.UnicastRemoteObject<DT>implements <A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke">RemoteInvoke</A></DL>

<P>
This class takes any object, and allows it to be called from
 remote VMs. This class eliminates the need to maintain multiple
 specialized rmic interface compilations for multiple, application specific
 objects. It effectively allows any object to be remoted, and makes all of
 the object's public methods remotely callable. It also contains several
 very useful utility methods, to further support the invoke package
 paradigm.<p> It can also be run as an application, to load an object from
 a URL, and remote it within a VM.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.0, 01-Nov-99 Initial release</DD>
<DT><B>Author:</B></DT>
  <DD>John Catherino</DD>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#gnu.cajo.invoke.Remote">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;gnu.cajo.invoke.Remote.RCSF</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#rcsf">rcsf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A global reference to the remote client socket factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;gnu.cajo.invoke.Remote.RSSF</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#rssf">rssf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A global reference to the remote server socket factory.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.rmi.server.RemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class java.rmi.server.RemoteObject</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>ref</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#Remote(java.lang.Object)">Remote</A></B>(java.lang.Object&nbsp;item)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The constructor takes <i>any</i> object, and allows it to be remotely
 invoked.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#autobox(java.lang.Class)">autobox</A></B>(java.lang.Class&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method emulates server J5SE argument autoboxing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#config(int, java.lang.String, int, java.lang.String, int, java.lang.String, java.lang.String)">config</A></B>(int&nbsp;serverPort,
       java.lang.String&nbsp;clientHost,
       int&nbsp;clientPort,
       java.lang.String&nbsp;proxyHost,
       int&nbsp;proxyPort,
       java.lang.String&nbsp;username,
       java.lang.String&nbsp;password)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method configures the server's TCP parameters for RMI through HTTP
 proxy servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#config(java.lang.String, int, java.lang.String, int)">config</A></B>(java.lang.String&nbsp;serverHost,
       int&nbsp;serverPort,
       java.lang.String&nbsp;clientHost,
       int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method configures the server's TCP parameters for RMI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to check if two Remote objects are holding an
 equavilent inner item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])">findBestMethod</A></B>(java.lang.Object&nbsp;item,
               java.lang.String&nbsp;method,
               java.lang.Class[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method attempts to resolve the argument inheritance blindness in
 Java reflection-based method selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getClientHost()">getClientHost</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the host name remote clients will
 use to contact this server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getClientPort()">getClientPort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the socket port number the remote
 client must use to contact the server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)">getItem</A></B>(java.lang.String&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A utility method to load either an item, or a zipped marshalled object
 (zedmob) of an item, from a URL, file, or from a remote rmiregistry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getServerHost()">getServerHost</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the server's host name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getServerPort()">getServerPort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the local  server socket port
 number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to identify the internal object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#invoke(java.lang.Object, java.lang.String, java.lang.Object)">invoke</A></B>(java.lang.Object&nbsp;item,
       java.lang.String&nbsp;method,
       java.lang.Object&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function may be called reentrantly, so the item object <i>must</i>
 synchronize its critical sections as necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#invoke(java.lang.String, java.lang.Object)">invoke</A></B>(java.lang.String&nbsp;method,
       java.lang.Object&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The sole generic, multi-purpose interface for communication between VMs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The application method loads a zipped marshalled object (zedmob) from a
 URL, or a file, and allows it run in this virtual machine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#send(java.lang.String)">send</A></B>(java.lang.String&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method sends its remote reference to another item, either from a
 URL, file, or from a remote rmiregistry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to identify the internal object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.InputStream)">zedmob</A></B>(java.io.InputStream&nbsp;is)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A utility method to reconstitute a zipped marshalled object (zedmob)
 into a remote item reference, proxy object, or local object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.OutputStream)">zedmob</A></B>(java.io.OutputStream&nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will write this remote item reference to an output stream
 as a zipped marshalled object (zedmob).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.OutputStream, java.lang.Object)">zedmob</A></B>(java.io.OutputStream&nbsp;os,
       java.lang.Object&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will write the local item, remote item reference, or proxy,
 to an output stream as a zipped marshalled object (zedmob).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.UnicastRemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.rmi.server.UnicastRemoteObject</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, exportObject, exportObject, exportObject, unexportObject</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.RemoteServer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.rmi.server.RemoteServer</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getLog, setLog</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.RemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.rmi.server.RemoteObject</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getRef, toStub</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="rcsf"><!-- --></A><H3>
rcsf</H3>
<PRE>
public static final gnu.cajo.invoke.Remote.RCSF <B>rcsf</B></PRE>
<DL>
<DD>A global reference to the remote client socket factory.  This is the
 factory remote VMs will use to communicate with local items.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rssf"><!-- --></A><H3>
rssf</H3>
<PRE>
public static final gnu.cajo.invoke.Remote.RSSF <B>rssf</B></PRE>
<DL>
<DD>A global reference to the remote server socket factory.  This is the
 factory the local items use to communicate with remote VMs.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Remote(java.lang.Object)"><!-- --></A><H3>
Remote</H3>
<PRE>
public <B>Remote</B>(java.lang.Object&nbsp;item)
       throws java.rmi.RemoteException</PRE>
<DL>
<DD>The constructor takes <i>any</i> object, and allows it to be remotely
 invoked. If the object implements the <A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke"><CODE>Invoke</CODE></A> interface,
 (i.e. it is an <tt>Item</tt>) it will simply route all remote
 invocations directly to it. Otherwise it will use Java reflection to
 attempt to invoke the remote calls directly on the object's public
 methods.
<P>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object to make remotely callable.  It may be an
 arbitrary object of any type, or an <b>Item</b> (either local or remote).
<DT><B>Throws:</B>
<DD><CODE>RemoteExcepiton</CODE> - If the remote instance could not be be created.
<DD><CODE>java.rmi.RemoteException</CODE></DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="autobox(java.lang.Class)"><!-- --></A><H3>
autobox</H3>
<PRE>
public static java.lang.Class <B>autobox</B>(java.lang.Class&nbsp;arg)</PRE>
<DL>
<DD>This method emulates server J5SE argument autoboxing. It is used by
 <A HREF="../../../gnu/cajo/invoke/Remote.html#findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])"><CODE>findBestMethod</CODE></A>. This technique has been most
 graciously championed by project member <b>Zac Wolfe</b>. It allows
 public server methods to use primitive types for arguments, <i>and</i>
 return values.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - The the argument class to test for boxing. If the argument
 <i>type</i> is primitive, it will be substituted with the corresponding
 primitive <i>class</i> representation.
<DT><B>Returns:</B><DD>The corresponding class matching the primitive type, or the
 original argument class, if it is not primitive.</DL>
</DD>
</DL>
<HR>

<A NAME="config(int, java.lang.String, int, java.lang.String, int, java.lang.String, java.lang.String)"><!-- --></A><H3>
config</H3>
<PRE>
public static void <B>config</B>(int&nbsp;serverPort,
                          java.lang.String&nbsp;clientHost,
                          int&nbsp;clientPort,
                          java.lang.String&nbsp;proxyHost,
                          int&nbsp;proxyPort,
                          java.lang.String&nbsp;username,
                          java.lang.String&nbsp;password)
                   throws java.net.UnknownHostException</PRE>
<DL>
<DD>This method configures the server's TCP parameters for RMI through HTTP
 proxy servers. This is necessary when the client or server, or both are
 behind firewalls, and the only method of access to the internet is
 through HTTP proxy servers. There will be a fairly significant performance
 hit incurred using the HTTP tunnel, but it is better than having no
 connectivity at all. Due to an unfortunate oversight in the design of
 the standard RMISocketFactory, no server network interface can be
 specified, instead it will listen on <i>all</i> network interfaces.
 It is probably not a problem for most, but is probably not desirable for
 multi-homed hosts.
 <p><i><u>Note</u>:</i> If this class is to be configured, it must be
 done <b>before</b> any items are remoted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>serverPort</CODE> - Specifies the local inbound port on which the server is
 serving clients. It can be zero, to use an anonymous port.  This must
 are being used, it must be an accessible port, into this server. If this
 port is zero, and the ClientPort argument is non-zero, then the
 ClientPort value will automatically substituted.<DD><CODE>clientHost</CODE> - The domain name, or IP address the remote client will
 use to communicate with this server.  If null, it will be the server's
 default host name.  This would need to be explicitly specified if
 the server is operating behind NAT i.e. when the server's subnet IP
 address is <i>not</i> the same as its address outside the subnet.<DD><CODE>clientPort</CODE> - Specifies the particular port on which the client
 will connect to the server.  Typically this is the <i>same</i> number
 as the serverPort argument, but could be different, if port translation
 is being used.  If the clientPort field is 0, i.e. anonymous, its port
 value will be automatically assigned to match the server, even if the
 server port is anonymous.<DD><CODE>proxyHost</CODE> - The name or address of the proxy server used to gain
 HTTP access to the internet.<DD><CODE>proxyPort</CODE> - The port number of the proxy server used to gain
 HTTP access to the internet.<DD><CODE>username</CODE> - The proxy account user name required for permission, if
 non-null.<DD><CODE>password</CODE> - The proxy account password required for permission, if
 required.
<DT><B>Throws:</B>
<DD><CODE>java.net.UnknownHostException</CODE> - If the IP address or name of the
 local host interface can not be determined.</DL>
</DD>
</DL>
<HR>

<A NAME="config(java.lang.String, int, java.lang.String, int)"><!-- --></A><H3>
config</H3>
<PRE>
public static void <B>config</B>(java.lang.String&nbsp;serverHost,
                          int&nbsp;serverPort,
                          java.lang.String&nbsp;clientHost,
                          int&nbsp;clientPort)
                   throws java.net.UnknownHostException</PRE>
<DL>
<DD>This method configures the server's TCP parameters for RMI.  It allows
 complete specification of client-side and server-side ports and
 hostnames.  It used to override the default values, which are anonymous,
 meaning from an unused pool, selected by the OS.  It is necessary
 when either VM is either operating behind a firewall, has multiple network
 interfaces, is multi-addressed, or is using NAT. The first two parameters
 control how the sockets will be configured locally, the second two
 control how a remote object's sockets will be configured to communicate
 with this server.
 <p><i><u>Note</u>:</i> If this class is to be configured, it must be
 done <b>before</b> any items are remoted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>serverHost</CODE> - The local domain name, or IP address of this host.
 If null, it will use all network interfaces.  Typically it is
 specified when the server has multiple phyisical network interfaces, or
 is multi-homed, i.e. having multiple logical network interfaces.<DD><CODE>serverPort</CODE> - Specifies the local port on which the server is
 serving clients. It can be zero, to use an anonymous port.  If firewalls
 are being used, it must be an accessible port, into this server. If this
 port is zero, and the ClientPort argument is non-zero, then the
 ClientPort value will automatically substituted.<DD><CODE>clientHost</CODE> - The domain name, or IP address the remote client will
 use to communicate with this server.  If null, it will be the same as
 serverHost resolution.  This would need to be explicitly specified if
 the server is operating behind NAT i.e. when the server's subnet IP
 address is <i>not</i> the same as its address outside the subnet.<DD><CODE>clientPort</CODE> - Specifies the particular port on which the client
 will connect to the server.  Typically this is the <i>same</i> number
 as the serverPort argument, but could be different, if port translation
 is being used.  If the clientPort field is 0, i.e. anonymous, its port
 value will be automatically assigned to match the server, even if the
 server port is anonymous.
<DT><B>Throws:</B>
<DD><CODE>java.net.UnknownHostException</CODE> - If the IP address or name of the
 serverHost can not be resolved.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;object)</PRE>
<DL>
<DD>This method is used to check if two Remote objects are holding an
 equavilent inner item. It short-circuit's the invocation, returning the
 result of the internal object's equals invocation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - A reference to another object to compare for equality.
<DT><B>Returns:</B><DD>The result of the equals method called on the internal object.</DL>
</DD>
</DL>
<HR>

<A NAME="findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])"><!-- --></A><H3>
findBestMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>findBestMethod</B>(java.lang.Object&nbsp;item,
                                                      java.lang.String&nbsp;method,
                                                      java.lang.Class[]&nbsp;args)</PRE>
<DL>
<DD>This method attempts to resolve the argument inheritance blindness in
 Java reflection-based method selection. It has been most graciously
 championed by project member <b>Fredrik Larsen</b>, with help from
 project member <b>Li Ma</b>. If more than one matching method is found,
 based on argument polymorphism, it will try to select the most
 applicable one. It works very well if the inheritence trees for the
 arguments are shallow. However, it may <i>not</i> always pick the best
 method if the arguments have deep inheritance trees. Fortunately it
 works for both classes, <i>and</i> interfaces.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object on which to find the most applicable public
 method.<DD><CODE>method</CODE> - The name of the method, which is to be invoked.<DD><CODE>args</CODE> - The class representations of the arguments to be
 provided to the method.
<DT><B>Returns:</B><DD>The most applicable method, which will accept all of these
 arguments, or null, if none match.</DL>
</DD>
</DL>
<HR>

<A NAME="getClientHost()"><!-- --></A><H3>
getClientHost</H3>
<PRE>
public static java.lang.String <B>getClientHost</B>()</PRE>
<DL>
<DD>This method is provided to obtain the host name remote clients will
 use to contact this server. This can be different from the local server
 name or address if NAT is being used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The server address clients use to connect to the server.</DL>
</DD>
</DL>
<HR>

<A NAME="getClientPort()"><!-- --></A><H3>
getClientPort</H3>
<PRE>
public static int <B>getClientPort</B>()</PRE>
<DL>
<DD>This method is provided to obtain the socket port number the remote
 client must use to contact the server.  This can be different from
 the server port number if NAT port translation is being used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The port clients must connect on to reach the server.</DL>
</DD>
</DL>
<HR>

<A NAME="getItem(java.lang.String)"><!-- --></A><H3>
getItem</H3>
<PRE>
public static java.lang.Object <B>getItem</B>(java.lang.String&nbsp;url)
                                throws java.rmi.RemoteException,
                                       java.rmi.NotBoundException,
                                       java.io.IOException,
                                       java.lang.ClassNotFoundException,
                                       java.lang.InstantiationException,
                                       java.lang.IllegalAccessException,
                                       java.net.MalformedURLException</PRE>
<DL>
<DD>A utility method to load either an item, or a zipped marshalled object
 (zedmob) of an item, from a URL, file, or from a remote rmiregistry.
 If the item is in a local file, it can be either inside the server's
 jar file, or on its local file system.<p> Loading an item from a file
 can be specified in one of three ways:<p><ul>
 <li>As a URL; in the format file://path/name.
 <li>As a class file; in the format path/name
 <li>As a serialized item; in the format /path/name</ul><p>
 File loading will first be attempted from within the server's jar file,
 if that fails, it will then look in the local filesystem.<p>
 <i><u>Note</u>:</i> any socket connections made by the incoming item
 cannot be known at compile time, therefore proper operation if this VM
 is behind a firewall could be blocked. Use behind a firewall would
 require knowing all the ports that would be needed in advance, and
 enabling them before loading the proxy.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>url</CODE> - The URL where to get the object: file://, http://, ftp://,
 /path/name, path/name, or //[host][:port]/[name]. The host, port,
 and name, are all optional. If missing the host is presumed local, the
 port 1099, and the name "main". The referenced resource can be
 returned as a MarshalledObject, it will be extracted automatically.
 If the URL is null, it will be assumed to be ///.
<DT><B>Returns:</B><DD>A reference to the item contained in the URL. It may be either
 local, or remote to this VM.
<DT><B>Throws:</B>
<DD><CODE>java.rmi.RemoteException</CODE> - if the remote registry could not be reached.
<DD><CODE>java.rmi.NotBoundException</CODE> - if the requested name is not in the registry.
<DD><CODE>java.io.IOException</CODE> - if the zedmob format is invalid.
<DD><CODE>java.lang.ClassNotFoundException</CODE> - if a proxy was sent to the VM, and
 proxy hosting was not enabled.
<DD><CODE>java.lang.InstantiationException</CODE> - when the URL specifies a class name
 which cannot be instantiated at runtime.
<DD><CODE>java.lang.IllegalAccessException</CODE> - when the url specifies a class name
 and it does not support a no-arg constructor.
<DD><CODE>java.net.MalformedURLException</CODE> - if the URL is not in the format explained</DL>
</DD>
</DL>
<HR>

<A NAME="getServerHost()"><!-- --></A><H3>
getServerHost</H3>
<PRE>
public static java.lang.String <B>getServerHost</B>()</PRE>
<DL>
<DD>This method is provided to obtain the server's host name.
 This is useful when the host can have one of multiple addresses, either
 because it has multiple network interface cards, or is multi-homed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The server address on which the item is remoted.</DL>
</DD>
</DL>
<HR>

<A NAME="getServerPort()"><!-- --></A><H3>
getServerPort</H3>
<PRE>
public static int <B>getServerPort</B>()</PRE>
<DL>
<DD>This method is provided to obtain the local  server socket port
 number. This can be particularly useful if the host was remoted on an
 anonymous port.  If a firewall is in use, this inbound port must be made
 accessible to outside clients.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The local ServerSocket port number on which the item is remoted.</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>This method is used to identify the internal object.  It short-circuit's
 the invocation, returning the result of the internal item's hashCode
 invocation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The semi-unique integer identifier for the internal object.</DL>
</DD>
</DL>
<HR>

<A NAME="invoke(java.lang.Object, java.lang.String, java.lang.Object)"><!-- --></A><H3>
invoke</H3>
<PRE>
public static java.lang.Object <B>invoke</B>(java.lang.Object&nbsp;item,
                                      java.lang.String&nbsp;method,
                                      java.lang.Object&nbsp;args)
                               throws java.lang.Exception</PRE>
<DL>
<DD>This function may be called reentrantly, so the item object <i>must</i>
 synchronize its critical sections as necessary. The specified method
 will be invoked, with the provided arguments if any, on the internal
 object's public method via the framework Java reflection mechanism, and
 the result returned, if any. The method is declared static to centralize
 the implementation, and allow other derived classes to use this
 mechanism without having to reimplement it. If the arguments are being
 sent to a remote VM, and are not already encapsulated in a
 MarshalledObject, they will be, automatically.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object on which to invoke the method. If the item
 implements the <A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke"><CODE>Invoke</CODE></A> interface, the call will be passed
 directly to it.<DD><CODE>method</CODE> - The method name to be invoked.<DD><CODE>args</CODE> - The arguments to provide to the method for its invocation.
<DT><B>Returns:</B><DD>The resulting data, if any, from the invocation.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - If the method argument is null.
<DD><CODE>java.lang.NoSuchMethodException</CODE> - If no matching method can be found.
<DD><CODE>java.lang.Exception</CODE> - If the item rejected the invocation, for application
 specific reasons.</DL>
</DD>
</DL>
<HR>

<A NAME="invoke(java.lang.String, java.lang.Object)"><!-- --></A><H3>
invoke</H3>
<PRE>
public java.lang.Object <B>invoke</B>(java.lang.String&nbsp;method,
                               java.lang.Object&nbsp;args)
                        throws java.lang.Exception</PRE>
<DL>
<DD>The sole generic, multi-purpose interface for communication between VMs.
 This function may be called reentrantly, so the inner object <i>must</i>
 synchronize its critical sections as necessary. Technically, it simply
 passes the call to this class' static invoke method. If the arriving
 arguments are encapsulated in a MarshalledObject, they will be extracted
 here automatically.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../gnu/cajo/invoke/Invoke.html#invoke(java.lang.String, java.lang.Object)">invoke</A></CODE> in interface <CODE><A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke">Invoke</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>method</CODE> - The method to invoke on the internal object.<DD><CODE>args</CODE> - The arguments to provide to the method for its invocation.
 It can be a single object, an array of objects, or even null.
<DT><B>Returns:</B><DD>The sychronous data, if any, resulting from the invocation.
<DT><B>Throws:</B>
<DD><CODE>java.rmi.RemoteException</CODE> - For network communication related
 reasons.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - If reflection is going to be used,
 and the method argument is null.
<DD><CODE>java.lang.NoSuchMethodException</CODE> - If no matching method can be found.
<DD><CODE>java.lang.Exception</CODE> - If the internal item rejected the invocation, for
 application specific reasons.</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)</PRE>
<DL>
<DD>The application method loads a zipped marshalled object (zedmob) from a
 URL, or a file, and allows it run in this virtual machine. It uses
 the <A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)"><CODE>getItem</CODE></A> method to load the item.  Following loading
 of the item, it will also create an rmiregistry, and bind a remote
 reference to it under the name "main".  This will also allow remote
 clients to connect to, and interact with it.<p>
 <i><u>Note</u>:</i>It will require a security policy, to define what
 permissions the loaded item will be allowed. There are six optional
 configuration parameters:<ul>
 <li> args[0] The optional URL where to get the object: file:// http://
 ftp:// ..., /path/name <serialized>, path/name <class>, or alternatively;
 //[host][:port]/[name].  If no arguments are provided, the URL will be
 assumed to be //localhost:1099/main.
 <li> args[1] The optional external client host name, if using NAT.
 <li> args[2] The optional external client port number, if using NAT.
 <li> args[3] The optional internal client host name, if multi home/NIC.
 <li> args[4] The optional internal client port number, if using NAT.
 <li> args[5] The optional URL where to get a proxy item: file://
 http:// ftp:// ..., //host:port/name (rmiregistry), /path/name
 (serialized), or path/name (class).  It will be passed into the loaded
 proxy as the sole argument to a setItem method invoked on the loaded item.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="send(java.lang.String)"><!-- --></A><H3>
send</H3>
<PRE>
public java.lang.Object <B>send</B>(java.lang.String&nbsp;url)
                      throws java.lang.Exception</PRE>
<DL>
<DD>This method sends its remote reference to another item, either from a
 URL, file, or from a remote rmiregistry. It will invoke the local
 <A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)"><CODE>getItem</CODE></A> method to obtain a reference to the remote
 item. It will next invoke the received reference's invoke method with
 a "send" value, and a reference to itself as its sole argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>url</CODE> - The URL where to get the remote host interface: file://,
 http://, ftp://, /path/name, path/name, or //[host][:port]/[name].
 The host, port, and name, are all optional. If missing the host is
 presumed local, the port 1099, and the name "main".  If the URL is
 null, it will be assumed to be ///.
<DT><B>Returns:</B><DD>Whatever the item returns in receipt of the reference,
 even null.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE> - Either from the getItem invocation, or if the
 item reference invocation fails.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>This method is used to identify the internal object.  It short-circuit's
 the invocation, returning the result of the internal object's toString
 invocation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The internal object's cannonical string identifier.</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.InputStream)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public static java.lang.Object <B>zedmob</B>(java.io.InputStream&nbsp;is)
                               throws java.lang.ClassNotFoundException,
                                      java.io.IOException</PRE>
<DL>
<DD>A utility method to reconstitute a zipped marshalled object (zedmob)
 into a remote item reference, proxy object, or local object.
 Typically a file containing a zedmob has the file extension .zmob as
 an identifier.<p>
 <i><u>Note</u>:</i> on completion of reading the item from the stream,
 the stream will be automatically closed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>is</CODE> - The input stream containing the zedmob of the item reference.
<DT><B>Returns:</B><DD>A reconstituted reference to the item.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if the zedmob format is invalid.
<DD><CODE>java.lang.ClassNotFoundException</CODE> - if a proxy object was sent, and remote
 class loading was not enabled in this VM.</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.OutputStream)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public void <B>zedmob</B>(java.io.OutputStream&nbsp;os)
            throws java.io.IOException</PRE>
<DL>
<DD>This method will write this remote item reference to an output stream
 as a zipped marshalled object (zedmob). A zedmob is the standard
 serialized format for a remote item reference, in this paradigm.
 This can be used to <i>'freeze-dry'</i> the remote reference, to a file
 for later use, send it over the network, or to an object archival
 service, for example.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>os</CODE> - The output stream on which to write the reference.  It may be
 a file stream, a socket stream, or any other type of stream.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - For any stream related writing error.</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.OutputStream, java.lang.Object)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public static void <B>zedmob</B>(java.io.OutputStream&nbsp;os,
                          java.lang.Object&nbsp;ref)
                   throws java.io.IOException</PRE>
<DL>
<DD>This method will write the local item, remote item reference, or proxy,
 to an output stream as a zipped marshalled object (zedmob). A zedmob is
 the standard serialized format in this paradigm. This can be used to
 <i>'freeze-dry'</i> the object to a file for later use, to send it over
 the network, or to an object archival service, for example.<p>
 <i><u>Note</u>:</i> on completion of writing the item, or reference, the
 stream will be closed. Typically, when saved to a file, a zedmob has the
 file extension .zmob to provide obvious identification.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>os</CODE> - The output stream on which to write the reference.  It may be
 a file stream, a socket stream, or any other type of stream.<DD><CODE>ref</CODE> - The item or reference to be serialized.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - For any stream related writing error.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../gnu/cajo/invoke/NoSecurityManager.html" title="class in gnu.cajo.invoke"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Remote.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
