<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Fri Sep 26 00:11:53 PDT 2008 -->
<TITLE>
Remote (The cajo project)
</TITLE>

<META NAME="keywords" CONTENT="gnu.cajo.invoke.Remote class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Remote (The cajo project)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../gnu/cajo/invoke/NoSecurityManager.html" title="class in gnu.cajo.invoke"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?gnu/cajo/invoke/Remote.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Remote.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
gnu.cajo.invoke</FONT>
<BR>
Class Remote</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.rmi.server.RemoteObject
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.rmi.server.RemoteServer
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.rmi.server.UnicastRemoteObject
              <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>gnu.cajo.invoke.Remote</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke">Invoke</A>, <A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke">RemoteInvoke</A>, java.io.Serializable, java.rmi.Remote, java.rmi.server.Unreferenced</DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>Remote</B><DT>extends java.rmi.server.UnicastRemoteObject<DT>implements <A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke">RemoteInvoke</A>, java.rmi.server.Unreferenced</DL>
</PRE>

<P>
This class takes any object, and allows it to be called from
 remote VMs. This class eliminates the need to maintain multiple
 specialized stubs for multiple, application specific objects. It
 effectively allows any object to be remoted, and makes all of
 the object's public methods, including its static ones, remotely callable.
 It also contains several very useful utility methods, to further support
 the invoke package paradigm.<p> It can also be run as an application, to
 load an object from a URL, and remote it within a JVM.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.0, 01-Nov-99 Initial release</DD>
<DT><B>Author:</B></DT>
  <DD>John Catherino</DD>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#gnu.cajo.invoke.Remote">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#item">item</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the reference to the local (or possibly remote) object
 reference being made remotely invokable by this Virtual Machine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;gnu.cajo.invoke.Remote.RCSF</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#rcsf">rcsf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A global reference to the remote client socket factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;gnu.cajo.invoke.Remote.RSSF</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#rssf">rssf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A global reference to the remote server socket factory.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.rmi.server.RemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class java.rmi.server.RemoteObject</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>ref</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#Remote(java.lang.Object)">Remote</A></B>(java.lang.Object&nbsp;item)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The constructor takes <i>any</i> object, and allows it to be remotely
 invoked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#Remote(java.lang.Object, int, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)">Remote</A></B>(java.lang.Object&nbsp;item,
       int&nbsp;port,
       java.rmi.server.RMIClientSocketFactory&nbsp;rcsf,
       java.rmi.server.RMIServerSocketFactory&nbsp;rssf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor allows for complete configuration of an object's
 remoting; normally this should be used for rare and highly specialised
 cases.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#Remote(java.lang.Object, java.lang.String)">Remote</A></B>(java.lang.Object&nbsp;item,
       java.lang.String&nbsp;localAddr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The constructor takes <i>any</i> object, and allows it to be remotely
 invoked.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#autobox(java.lang.Class)">autobox</A></B>(java.lang.Class&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method emulates server J5SE argument autoboxing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../gnu/cajo/invoke/Remote.html" title="class in gnu.cajo.invoke">Remote</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#clientScope()">clientScope</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method controls the automatic-unexporting of a remote reference
 when it is no longer referenced by any clients.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#config(int, java.lang.String, int, java.lang.String, int, java.lang.String, java.lang.String)">config</A></B>(int&nbsp;serverPort,
       java.lang.String&nbsp;clientHost,
       int&nbsp;clientPort,
       java.lang.String&nbsp;proxyHost,
       int&nbsp;proxyPort,
       java.lang.String&nbsp;username,
       java.lang.String&nbsp;password)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method configures the server's TCP parameters for RMI through HTTP
 proxy servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#config(java.lang.String, int, java.lang.String, int)">config</A></B>(java.lang.String&nbsp;serverHost,
       int&nbsp;serverPort,
       java.lang.String&nbsp;clientHost,
       int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method configures the server's TCP parameters for RMI.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])">findBestMethod</A></B>(java.lang.Object&nbsp;item,
               java.lang.String&nbsp;method,
               java.lang.Class[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method attempts to resolve the argument inheritance blindness in
 Java reflection-based method selection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getClientHost()">getClientHost</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the host name remote clients will
 use to contact this server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getClientPort()">getClientPort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the socket port number the remote
 client must use to contact the server.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)">getItem</A></B>(java.lang.String&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A utility method to load either an item, or a zipped marshalled object
 (zedmob) of an item, from a URL, file, or from a remote rmiregistry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getServerHost()">getServerHost</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the server's host name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#getServerPort()">getServerPort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is provided to obtain the local  server socket port
 number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#invoke(java.lang.Object, java.lang.String, java.lang.Object)">invoke</A></B>(java.lang.Object&nbsp;item,
       java.lang.String&nbsp;method,
       java.lang.Object&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function may be called reentrantly, so the item object <i>must</i>
 synchronize its critical sections as necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#invoke(java.lang.String, java.lang.Object)">invoke</A></B>(java.lang.String&nbsp;method,
       java.lang.Object&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The sole generic, multi-purpose interface for communication between VMs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The application method loads a zipped marshalled object (zedmob) from a
 URL, or a file, and allows it run in this virtual machine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#send(java.lang.String)">send</A></B>(java.lang.String&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method sends its remote reference to another item, either from a
 URL, file, or from a remote rmiregistry.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will brutally un-remote all currently remotely invocable
 wrappers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#unexport(boolean)">unexport</A></B>(boolean&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will attempt to make the wrapper no longer remotely invocable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#unreferenced()">unreferenced</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is called by the RMI runtime sometime after it determines
 the collection of listening clients becomes empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.InputStream)">zedmob</A></B>(java.io.InputStream&nbsp;is)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A utility method to reconstitute a zipped marshalled object (zedmob)
 into a remote item reference, proxy object, or local object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.OutputStream)">zedmob</A></B>(java.io.OutputStream&nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will write this remote item reference to an output stream
 as a zipped marshalled object (zedmob).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../gnu/cajo/invoke/Remote.html#zedmob(java.io.OutputStream, java.lang.Object)">zedmob</A></B>(java.io.OutputStream&nbsp;os,
       java.lang.Object&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will write the local item, remote item reference, or proxy,
 to an output stream as a zipped marshalled object (zedmob).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.UnicastRemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.rmi.server.UnicastRemoteObject</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, exportObject, exportObject, exportObject, unexportObject</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.RemoteServer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.rmi.server.RemoteServer</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getLog, setLog</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.rmi.server.RemoteObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.rmi.server.RemoteObject</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getRef, hashCode, toString, toStub</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="rcsf"><!-- --></A><H3>
rcsf</H3>
<PRE>
public static final gnu.cajo.invoke.Remote.RCSF <B>rcsf</B></PRE>
<DL>
<DD>A global reference to the remote client socket factory.  This is the
 factory remote VMs will use to communicate with local items.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rssf"><!-- --></A><H3>
rssf</H3>
<PRE>
public static final gnu.cajo.invoke.Remote.RSSF <B>rssf</B></PRE>
<DL>
<DD>A global reference to the remote server socket factory.  This is the
 factory the local items use to communicate with remote VMs.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="item"><!-- --></A><H3>
item</H3>
<PRE>
public final java.lang.Object <B>item</B></PRE>
<DL>
<DD>This is the reference to the local (or possibly remote) object
 reference being made remotely invokable by this Virtual Machine. It is
 declared public to provide the convenience to refer to both the
 wrapper, and its wrapped object, via a single reference.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Remote(java.lang.Object)"><!-- --></A><H3>
Remote</H3>
<PRE>
public <B>Remote</B>(java.lang.Object&nbsp;item)
       throws java.rmi.RemoteException</PRE>
<DL>
<DD>The constructor takes <i>any</i> object, and allows it to be remotely
 invoked. If the object implements the <A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke"><CODE>Invoke</CODE></A> interface,
 it will route all remote invocations directly to it. Otherwise it will
 use Java reflection to attempt to invoke the remote calls directly on
 the object's public methods.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object to make remotely callable.  It may be an
 arbitrary object of any type, it can even be a reference to a remote
 reference from another host, being re-remoted through this JVM.
<DT><B>Throws:</B>
<DD><CODE>RemoteExcepiton</CODE> - If the remote instance could not be be created.
<DD><CODE>java.rmi.RemoteException</CODE></DL>
</DL>
<HR>

<A NAME="Remote(java.lang.Object, java.lang.String)"><!-- --></A><H3>
Remote</H3>
<PRE>
public <B>Remote</B>(java.lang.Object&nbsp;item,
              java.lang.String&nbsp;localAddr)
       throws java.rmi.RemoteException</PRE>
<DL>
<DD>The constructor takes <i>any</i> object, and allows it to be remotely
 invoked. If the object implements the <A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke"><CODE>Invoke</CODE></A> interface,
 it will route all remote invocations directly to it. Otherwise it will
 use Java reflection to attempt to invoke the remote calls directly on the
 object's public methods.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object to make remotely callable.  It may be an
 arbitrary object of any type, it can even be a reference to a remote
 reference from another host, being re-remoted through this JVM.<DD><CODE>localAddr</CODE> - The NAT internal address. This is used to remote
 objects for use by clients <i>inside</i> a NAT subnet. This is often
 needed for routers like LinkSys, which do not allow clients inside the
 NAT subnet to use a hosts external address. For example, the externally
 accessible reference could be created from the single-argument
 constructor under the name and bound under the name <tt>externalItem,</tt>
 and the locally accessible item could be created with this constructor,
 and bound under the name <tt>internalItem.</tt>
<DT><B>Throws:</B>
<DD><CODE>RemoteExcepiton</CODE> - If the remote instance could not be be created.
<DD><CODE>java.rmi.RemoteException</CODE></DL>
</DL>
<HR>

<A NAME="Remote(java.lang.Object, int, java.rmi.server.RMIClientSocketFactory, java.rmi.server.RMIServerSocketFactory)"><!-- --></A><H3>
Remote</H3>
<PRE>
public <B>Remote</B>(java.lang.Object&nbsp;item,
              int&nbsp;port,
              java.rmi.server.RMIClientSocketFactory&nbsp;rcsf,
              java.rmi.server.RMIServerSocketFactory&nbsp;rssf)
       throws java.rmi.RemoteException</PRE>
<DL>
<DD>This constructor allows for complete configuration of an object's
 remoting; normally this should be used for rare and highly specialised
 cases.
 <i><u>Note</u>:</i> the RMIClientSocketFactory <b><i>must</i></b> be
 seriallisable.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object to make remotely callable.  It may be an
 arbitrary object of any type, it can even be a reference to a remote
 reference from another host, being re-remoted through this JVM.<DD><CODE>port</CODE> - The TCP port number on which to communicate with the object<DD><CODE>rcsf</CODE> - The custom client socket factory to be used to communicate
 with this item, by remote clients. (please regard carefully the note
 above)<DD><CODE>rssf</CODE> - The custom server socket factory to be used to accept
 connections from remote clients.
<DT><B>Throws:</B>
<DD><CODE>RemoteExcepiton</CODE> - If the remote instance could not be be created.
<DD><CODE>java.rmi.RemoteException</CODE></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getServerHost()"><!-- --></A><H3>
getServerHost</H3>
<PRE>
public static java.lang.String <B>getServerHost</B>()</PRE>
<DL>
<DD>This method is provided to obtain the server's host name.
 This is useful when the host can have multiple addresses, either
 because it has multiple network interface cards, or is multi-homed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The server address on which the item is remoted.</DL>
</DD>
</DL>
<HR>

<A NAME="getServerPort()"><!-- --></A><H3>
getServerPort</H3>
<PRE>
public static int <B>getServerPort</B>()</PRE>
<DL>
<DD>This method is provided to obtain the local  server socket port
 number. This can be particularly useful if the host was remoted on an
 anonymous port.  If a firewall is in use, this inbound port must be made
 accessible to outside clients.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The local ServerSocket port number on which the item is remoted.</DL>
</DD>
</DL>
<HR>

<A NAME="getClientHost()"><!-- --></A><H3>
getClientHost</H3>
<PRE>
public static java.lang.String <B>getClientHost</B>()</PRE>
<DL>
<DD>This method is provided to obtain the host name remote clients will
 use to contact this server. This can be different from the local server
 name or address if NAT is being used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The server address clients use to connect to the server.</DL>
</DD>
</DL>
<HR>

<A NAME="getClientPort()"><!-- --></A><H3>
getClientPort</H3>
<PRE>
public static int <B>getClientPort</B>()</PRE>
<DL>
<DD>This method is provided to obtain the socket port number the remote
 client must use to contact the server.  This can be different from
 the server port number if port translation is being used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The port clients must connect on to reach the server.</DL>
</DD>
</DL>
<HR>

<A NAME="config(java.lang.String, int, java.lang.String, int)"><!-- --></A><H3>
config</H3>
<PRE>
public static void <B>config</B>(java.lang.String&nbsp;serverHost,
                          int&nbsp;serverPort,
                          java.lang.String&nbsp;clientHost,
                          int&nbsp;clientPort)
                   throws java.net.UnknownHostException</PRE>
<DL>
<DD>This method configures the server's TCP parameters for RMI.  It allows
 complete specification of client-side and server-side ports and
 hostnames.  It used to override the default values, which are anonymous,
 meaning from an unused pool, selected by the OS.  It is necessary
 when either the VM is operating behind a firewall, has multiple network
 interfaces, is multi-homed, or is using NAT. The first two parameters
 control how the sockets will be configured locally, the second two
 control how a remote object's sockets will be configured to communicate
 with this server.
 <p><i><u>Note</u>:</i> If this class is to be configured, it must be
 done <b>before</b> any items are remoted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>serverHost</CODE> - The local domain name, or IP address of this host.
 If null, it will use the primary network interface. Typically it is
 specified when the server has multiple phyisical network interfaces, or
 is multi-homed, i.e. having multiple logical network interfaces. It can
 <i>also</i> be specified as "0.0.0.0" to use <i><u>all</u></i> of the
 machine's network interfaces.<DD><CODE>serverPort</CODE> - Specifies the local port on which the server is
 serving clients. It can be zero, to use an anonymous port. If firewalls
 are being used, it must be an accessible port, into this server. If this
 port is zero, and the ClientPort argument is non-zero, then the
 ClientPort value will automatically substituted.<DD><CODE>clientHost</CODE> - The host name, or IP address the remote client will
 use to communicate with this server.  If null, it will be the same as
 serverHost resolution.  This would need to be explicitly specified if
 the server is operating behind NAT; i.e. when the server's subnet IP
 address is <i>not</i> the same as its address outside the subnet.<DD><CODE>clientPort</CODE> - Specifies the particular port on which the client
 will connect to the server.  Typically this is the <i>same</i> number
 as the serverPort argument, but could be different, if port translation
 is being used.  If the clientPort field is 0, i.e. anonymous, its port
 value will be automatically assigned to match the server, even if the
 server port is also anonymous.
<DT><B>Throws:</B>
<DD><CODE>java.net.UnknownHostException</CODE> - If the IP address or name of the
 serverHost can not be resolved.</DL>
</DD>
</DL>
<HR>

<A NAME="config(int, java.lang.String, int, java.lang.String, int, java.lang.String, java.lang.String)"><!-- --></A><H3>
config</H3>
<PRE>
public static void <B>config</B>(int&nbsp;serverPort,
                          java.lang.String&nbsp;clientHost,
                          int&nbsp;clientPort,
                          java.lang.String&nbsp;proxyHost,
                          int&nbsp;proxyPort,
                          java.lang.String&nbsp;username,
                          java.lang.String&nbsp;password)
                   throws java.net.UnknownHostException</PRE>
<DL>
<DD>This method configures the server's TCP parameters for RMI through HTTP
 proxy servers. This is necessary when the client or server, or both,
 are behind firewalls, and the only method of access to the internet is
 through HTTP proxy servers. There will be a fairly significant
 performance hit incurred using the HTTP tunnel, but it is better than
 having no connectivity at all. Due to an unfortunate oversight in the
 design of the standard RMISocketFactory, no server network interface can
 be specified, instead it will listen on <i>all</i> network interfaces.
 It is probably not a problem for most, but is probably not desirable for
 multi-homed hosts.
 <p><i><u>Note</u>:</i> If this class is to be configured, it must be
 done <b>before</b> any items are remoted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>serverPort</CODE> - Specifies the local port on which the server is
 serving clients. It can be zero, to use an anonymous port. If firewalls
 are being used, it must be an accessible port, into this server. If this
 port is zero, and the ClientPort argument is non-zero, then the
 ClientPort value will automatically substituted.<DD><CODE>clientHost</CODE> - The host name, or IP address the remote client will
 use to communicate with this server.  If null, it will be the same as
 serverHost resolution.  This would need to be explicitly specified if
 the server is operating behind NAT; i.e. when the server's subnet IP
 address is <i>not</i> the same as its address outside the subnet.<DD><CODE>clientPort</CODE> - Specifies the particular port on which the client
 will connect to the server.  Typically this is the <i>same</i> number
 as the serverPort argument, but could be different, if port translation
 is being used.  If the clientPort field is 0, i.e. anonymous, its port
 value will be automatically assigned to match the server, even if the<DD><CODE>proxyHost</CODE> - The name or address of the proxy server used to gain
 HTTP access to the internet.<DD><CODE>proxyPort</CODE> - The port number of the proxy server used to gain
 HTTP access to the internet.<DD><CODE>username</CODE> - The proxy account user name required for permission, if
 non-null.<DD><CODE>password</CODE> - The proxy account password required for permission, if
 non-null.
<DT><B>Throws:</B>
<DD><CODE>java.net.UnknownHostException</CODE> - If the IP address or name of the
 local host interface can not be determined.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public static void <B>shutdown</B>()</PRE>
<DL>
<DD>This method will brutally un-remote all currently remotely invocable
 wrappers. This can be used to allow the JVM to shut down without having
 to call <tt>System.exit()</tt> also, to support use in managed container
 systems. Following this execution, objects can be newly remoted again.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.InputStream)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public static java.lang.Object <B>zedmob</B>(java.io.InputStream&nbsp;is)
                               throws java.lang.ClassNotFoundException,
                                      java.io.IOException</PRE>
<DL>
<DD>A utility method to reconstitute a zipped marshalled object (zedmob)
 into a remote item reference, proxy object, or local object.
 Typically a file containing a zedmob has the file extension .zmob as
 an identifier.<p>
 <i><u>Note</u>:</i> on completion of reading the item from the stream,
 the stream will be automatically closed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>is</CODE> - The input stream containing the zedmob of the item reference.
<DT><B>Returns:</B><DD>A reconstituted reference to the item.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if the zedmob format is invalid.
<DD><CODE>java.lang.ClassNotFoundException</CODE> - if a proxy object was sent, and remote
 class loading was not enabled in this VM.</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.OutputStream, java.lang.Object)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public static void <B>zedmob</B>(java.io.OutputStream&nbsp;os,
                          java.lang.Object&nbsp;ref)
                   throws java.io.IOException</PRE>
<DL>
<DD>This method will write the local item, remote item reference, or proxy,
 to an output stream as a zipped marshalled object (zedmob). A zedmob is
 the standard serialized format in this paradigm. This can be used to
 <i>'freeze-dry'</i> the object to a file for later use, to send it over
 the network, or to an object archival service, for example.<p>
 <i><u>Note</u>:</i> on completion of writing the item, or reference, the
 stream will be closed. Typically, when saved to a file, a zedmob has the
 file extension .zmob to provide obvious identification.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>os</CODE> - The output stream on which to write the reference.  It may be
 a file stream, a socket stream, or any other type of stream.<DD><CODE>ref</CODE> - The item or reference to be serialized.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - For any stream related writing error.</DL>
</DD>
</DL>
<HR>

<A NAME="getItem(java.lang.String)"><!-- --></A><H3>
getItem</H3>
<PRE>
public static java.lang.Object <B>getItem</B>(java.lang.String&nbsp;url)
                                throws java.rmi.RemoteException,
                                       java.rmi.NotBoundException,
                                       java.io.IOException,
                                       java.lang.ClassNotFoundException,
                                       java.lang.InstantiationException,
                                       java.lang.IllegalAccessException,
                                       java.net.MalformedURLException</PRE>
<DL>
<DD>A utility method to load either an item, or a zipped marshalled object
 (zedmob) of an item, from a URL, file, or from a remote rmiregistry.
 If the item is in a local file, it can be either inside the server's
 jar file, or on its local file system.<p> Loading an item from a file
 can be specified in one of three ways:<p><ul>
 <li>As a URL; in the format file://path/name.
 <li>As a class file; in the format path/name
 <li>As a serialized item; in the format /path/name</ul><p>
 File loading will first be attempted from within the server's jar file,
 if that fails, it will then look in the local filesystem.<p>
 <i><u>Note</u>:</i> any socket connections made by the incoming item
 cannot be known at compile time, therefore proper operation if this VM
 is behind a firewall could be blocked. Use behind a firewall would
 require knowing all the ports that would be needed in advance, and
 enabling them before loading the proxy.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>url</CODE> - The URL where to get the object: file://, http://, ftp://,
 /path/name, path/name, or //[host][:port]/[name]. The host, port,
 and name, are all optional. If missing the host is presumed local, the
 port 1099, and the name "main". The referenced resource can be
 returned as a MarshalledObject, it will be extracted automatically.
 If the URL is null, it will be assumed to be ///.
<DT><B>Returns:</B><DD>A reference to the item contained in the URL. It may be either
 local, or remote to this VM.
<DT><B>Throws:</B>
<DD><CODE>java.rmi.RemoteException</CODE> - if the remote registry could not be reached.
<DD><CODE>java.rmi.NotBoundException</CODE> - if the requested name is not in the registry.
<DD><CODE>java.io.IOException</CODE> - if the zedmob format is invalid.
<DD><CODE>java.lang.ClassNotFoundException</CODE> - if a proxy was sent to the VM, and
 proxy hosting was not enabled.
<DD><CODE>java.lang.InstantiationException</CODE> - when the URL specifies a class name
 which cannot be instantiated at runtime.
<DD><CODE>java.lang.IllegalAccessException</CODE> - when the url specifies a class name
 and it does not support a no-arg constructor.
<DD><CODE>java.net.MalformedURLException</CODE> - if the URL is not in the format explained</DL>
</DD>
</DL>
<HR>

<A NAME="autobox(java.lang.Class)"><!-- --></A><H3>
autobox</H3>
<PRE>
public static java.lang.Class <B>autobox</B>(java.lang.Class&nbsp;arg)</PRE>
<DL>
<DD>This method emulates server J5SE argument autoboxing. It is used by
 <A HREF="../../../gnu/cajo/invoke/Remote.html#findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])"><CODE>findBestMethod</CODE></A>. This technique has been most
 graciously championed by project member <b>Zac Wolfe</b>. It allows
 public server methods to use primitive types for arguments, <i>and</i>
 return values.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - The the argument class to test for boxing. If the argument
 <i>type</i> is primitive, it will be substituted with the corresponding
 primitive <i>class</i> representation.
<DT><B>Returns:</B><DD>The corresponding class matching the primitive type, or the
 original argument class, if it is not primitive.</DL>
</DD>
</DL>
<HR>

<A NAME="findBestMethod(java.lang.Object, java.lang.String, java.lang.Class[])"><!-- --></A><H3>
findBestMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>findBestMethod</B>(java.lang.Object&nbsp;item,
                                                      java.lang.String&nbsp;method,
                                                      java.lang.Class[]&nbsp;args)</PRE>
<DL>
<DD>This method attempts to resolve the argument inheritance blindness in
 Java reflection-based method selection. It has been most graciously
 championed by project member <b>Fredrik Larsen</b>, with help from
 project member <b>Li Ma</b>. If more than one matching method is found,
 based on argument polymorphism, it will try to select the most
 applicable one. It works very well if the inheritence trees for the
 arguments are shallow. However, it may <i>not</i> always pick the best
 method if the arguments have deep inheritance trees. Fortunately it
 works for both classes, <i>and</i> interfaces.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object on which to find the most applicable public
 method.<DD><CODE>method</CODE> - The name of the method, which is to be invoked.<DD><CODE>args</CODE> - The class representations of the arguments to be
 provided to the method.
<DT><B>Returns:</B><DD>The most applicable method, which will accept all of these
 arguments, or null, if none match.</DL>
</DD>
</DL>
<HR>

<A NAME="invoke(java.lang.Object, java.lang.String, java.lang.Object)"><!-- --></A><H3>
invoke</H3>
<PRE>
public static java.lang.Object <B>invoke</B>(java.lang.Object&nbsp;item,
                                      java.lang.String&nbsp;method,
                                      java.lang.Object&nbsp;args)
                               throws java.lang.Exception</PRE>
<DL>
<DD>This function may be called reentrantly, so the item object <i>must</i>
 synchronize its critical sections as necessary. The specified method
 will be invoked, with the provided arguments if any, on the internal
 object's public method via the framework Java reflection mechanism, and
 the result returned, if any. The method is declared static to centralize
 the implementation, and allow other derived classes to use this
 mechanism without having to reimplement it. If the arguments are being
 sent to a remote VM, and are not already encapsulated in a
 MarshalledObject, they will be, automatically.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>item</CODE> - The object on which to invoke the method. If the item
 implements the <A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke"><CODE>Invoke</CODE></A> interface, the call will be passed
 directly to it.<DD><CODE>method</CODE> - The method name to be invoked.<DD><CODE>args</CODE> - The arguments to provide to the method for its invocation.
<DT><B>Returns:</B><DD>The resulting data, if any, from the invocation.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - If the method argument is null.
<DD><CODE>java.lang.NoSuchMethodException</CODE> - If no matching method can be found.
<DD><CODE>java.lang.Exception</CODE> - If the item rejected the invocation, for application
 specific reasons.</DL>
</DD>
</DL>
<HR>

<A NAME="unexport(boolean)"><!-- --></A><H3>
unexport</H3>
<PRE>
public boolean <B>unexport</B>(boolean&nbsp;force)
                 throws java.rmi.NoSuchObjectException</PRE>
<DL>
<DD>This method will attempt to make the wrapper no longer remotely invocable.
 As a list of all remoted wrappers is maintained, this method will remove
 the reference from the list. If a lot of objects are being remoted and
 unremoted during the life of the JVM, it is highly recommended to use this
 method, rather than the inherited static unexportObject method, as it will
 not remove the reference from the internal list.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>force</CODE> - true to un-remote the object wrapper, even if invocations are in
 progress or pending, if false, do not un-remote unless idle.
<DT><B>Returns:</B><DD>true if the wrapper was successfully un-remoted, false if it is
 still remoted.
<DT><B>Throws:</B>
<DD><CODE>java.rmi.NoSuchObjectException</CODE> - If this wrapper has already been un-remoted</DL>
</DD>
</DL>
<HR>

<A NAME="invoke(java.lang.String, java.lang.Object)"><!-- --></A><H3>
invoke</H3>
<PRE>
public java.lang.Object <B>invoke</B>(java.lang.String&nbsp;method,
                               java.lang.Object&nbsp;args)
                        throws java.lang.Exception</PRE>
<DL>
<DD>The sole generic, multi-purpose interface for communication between VMs.
 This function may be called reentrantly, so the inner object <i>must</i>
 synchronize its critical sections as necessary. Technically, it simply
 passes the call to this class' static invoke method. If the arriving
 arguments are encapsulated in a MarshalledObject, they will be extracted
 here automatically.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../gnu/cajo/invoke/Invoke.html#invoke(java.lang.String, java.lang.Object)">invoke</A></CODE> in interface <CODE><A HREF="../../../gnu/cajo/invoke/Invoke.html" title="interface in gnu.cajo.invoke">Invoke</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>method</CODE> - The method to invoke on the internal object.<DD><CODE>args</CODE> - The arguments to provide to the method for its invocation.
 It can be a single object, an array of objects, or even null.
<DT><B>Returns:</B><DD>The sychronous data, if any, resulting from the invocation.
<DT><B>Throws:</B>
<DD><CODE>java.rmi.RemoteException</CODE> - For network communication related
 reasons.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - If reflection is going to be used,
 and the method argument is null.
<DD><CODE>java.lang.NoSuchMethodException</CODE> - If no matching method can be found.
<DD><CODE>java.lang.Exception</CODE> - If the internal item rejected the invocation, for
 application specific reasons.</DL>
</DD>
</DL>
<HR>

<A NAME="send(java.lang.String)"><!-- --></A><H3>
send</H3>
<PRE>
public java.lang.Object <B>send</B>(java.lang.String&nbsp;url)
                      throws java.lang.Exception</PRE>
<DL>
<DD>This method sends its remote reference to another item, either from a
 URL, file, or from a remote rmiregistry. It will invoke the local
 <A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)"><CODE>getItem</CODE></A> method to obtain a reference to the remote
 item. It will next invoke the received reference's invoke method with
 a "send" value, and a reference to itself as its sole argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>url</CODE> - The URL where to get the remote host interface: file://,
 http://, ftp://, /path/name, path/name, or //[host][:port]/[name].
 The host, port, and name, are all optional. If missing the host is
 presumed local, the port 1099, and the name "main".  If the URL is
 null, it will be assumed to be ///.
<DT><B>Returns:</B><DD>Whatever the item returns in receipt of the reference,
 even null.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE> - Either from the getItem invocation, or if the
 item reference invocation fails.</DL>
</DD>
</DL>
<HR>

<A NAME="zedmob(java.io.OutputStream)"><!-- --></A><H3>
zedmob</H3>
<PRE>
public void <B>zedmob</B>(java.io.OutputStream&nbsp;os)
            throws java.io.IOException</PRE>
<DL>
<DD>This method will write this remote item reference to an output stream
 as a zipped marshalled object (zedmob). A zedmob is the standard
 serialized format for a remote item reference, in this paradigm.
 This can be used to <i>'freeze-dry'</i> the remote reference, to a file
 for later use, send it over the network, or to an object archival
 service, for example.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>os</CODE> - The output stream on which to write the reference.  It may be
 a file stream, a socket stream, or any other type of stream.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - For any stream related writing error.</DL>
</DD>
</DL>
<HR>

<A NAME="unreferenced()"><!-- --></A><H3>
unreferenced</H3>
<PRE>
public void <B>unreferenced</B>()</PRE>
<DL>
<DD>This method is called by the RMI runtime sometime after it determines
 the collection of listening clients becomes empty. If the wrapped
 object whishes to be notified of being unreferenced, it need only
 implement the java.rmi.server.Unreferenced interface itself, and the
 invocation will be passed along. Normally it is used to close any open
 resources, needed to serve its clients. Highest thanks to Petr Stepan,
 for the suggestion for this most excellent addition.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>unreferenced</CODE> in interface <CODE>java.rmi.server.Unreferenced</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clientScope()"><!-- --></A><H3>
clientScope</H3>
<PRE>
public <A HREF="../../../gnu/cajo/invoke/Remote.html" title="class in gnu.cajo.invoke">Remote</A> <B>clientScope</B>()</PRE>
<DL>
<DD>This method controls the automatic-unexporting of a remote reference
 when it is no longer referenced by any clients. Often an application
 will provide a remote reference to a special short-term use object on
 the client side. The RMI runtime does not automatically unexport remote
 references, as they typically belong to server objects. Remoted object
 references used for temporary transactions, e.g. Futures, can quickly
 accumulate into a large memory leak. Once unexported, this remote
 object wrapper is no longer remotely invocable. The wrapped object can
 be provided to a new instance of Remote, to make it remotely invocable
 again. It effectively places the lifetime of this object under the
 control of the client(s), rather than the server, which is normally the
 case. Quite simply, it causes the unexport method to be called
 implicitly, when the wrapper becomes unreferenced by all clients.
 Very handy and important!
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A reference to this wrapper, purely to allow the convenient
 construct of:<p><tt>
 return(new Remote(tempObj).clientScope();</tt></DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)
                 throws java.lang.Exception</PRE>
<DL>
<DD>The application method loads a zipped marshalled object (zedmob) from a
 URL, or a file, and allows it run in this virtual machine. It uses
 the <A HREF="../../../gnu/cajo/invoke/Remote.html#getItem(java.lang.String)"><CODE>getItem</CODE></A> method to load the item.  Following loading
 of the item, it will also create an rmiregistry, and bind a remote
 reference to it under the name "main".  This will also allow remote
 clients to connect to, and interact with it.<p>
 <i><u>Note</u>:</i>It will require a security policy, to define what
 permissions the loaded item will be allowed. There are six optional
 configuration parameters:<ul>
 <li> args[0] The optional URL where to get the object: file:// http://
 ftp:// ..., /path/name <serialized>, path/name <class>, or alternatively;
 //[host][:port]/[name].  If no arguments are provided, the URL will be
 assumed to be //localhost:1099/main.
 <li> args[1] The optional external client host name, if using NAT.
 <li> args[2] The optional external client port number, if using NAT.
 <li> args[3] The optional internal client host name, if multi home/NIC.
 <li> args[4] The optional internal client port number, if using NAT.
 <li> args[5] The optional URL where to get a proxy item: file://
 http:// ftp:// ..., //host:port/name (rmiregistry), /path/name
 (serialized), or path/name (class).  It will be passed into the loaded
 proxy as the sole argument to a setItem method invoked on the loaded item.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../gnu/cajo/invoke/NoSecurityManager.html" title="class in gnu.cajo.invoke"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../gnu/cajo/invoke/RemoteInvoke.html" title="interface in gnu.cajo.invoke"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?gnu/cajo/invoke/Remote.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Remote.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
