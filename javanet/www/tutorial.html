<html>
   <head>
      <title>The CaJo Project</title>
      <meta name="Keywords" content="cajo, rmi, java, distributed computing, Transparent Distributed Computing">
      <meta name="Description" content="Cajo Distributed Application Framework">
      <meta name="Author" content="John Catherino">
   </head>
   <body>
      <div id="projecthome" class="app">
      <table width="100%">
         <tr>
            <td width="120" valign="top">
               <table width="120" border="0" cellspacing="2" cellpadding="2" align="left">
<!-- begin table.html -->
                  <tr class="a">
                     <td>
                        <a href="index.html" title="cajo home page"><b>Welcome</b></a><br>
                     </td>
                  </tr>
                  <tr class="b">
                     <td>
                        <b><u>Tutorial</u></b>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="theory.html" title="how it all works"><b>Theory</b></a>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="gotcha.html" title="important details"><b>Gotchas</b></a>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="faq.html" title="common questions"><b>FAQ</b></a>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="acknowlege.html" title="supporters of the marque"><b>Acknowledgments</b></a>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="license.html" title="what's the LGPL"><b>License</b></a>
                     </td>
                  </tr>
                  <tr class="a">
                     <td>
                        <a href="docs/overview-summary.html" title="package documentation"><b>Javadocs</b></a>
                     </td>
                  </tr>
<!-- end table.html -->
               </table>
            </td>
            <td width="100%" valign="top">
               <table width="100%" cellpadding="5">
                  <tr>
                     <td>
<!-- begin main.html -->
                           <font size="4">
                              <b>Getting started with the cajo framework.</b>
                              <br><br>
                           </font>
                           Hopefully his page will help to get you up and running as quickly as
                           possible.  Once you can build it, and understand its basic components, then
                           the possibilities become truly limitless.<br><br>

                           The tutorial will start by describing the <a href="#directory">directory</a>
                           structure and its components. Next it will move on to
                           <a href=#building>building</a> and <a href=#launching>launching</a> the
                           example server, and their related options.  It will conclude by describing
                           the ways of <a href=#connecting>connecting</a> to the server. This should
                           provide a fairly complete introduction to the use of the framework.<br><br>

                           The purpose of the example is to illustrate the structure of building servers,
                           and the feature set of the architecture.  It should provide you with enough
                           insight to build and deploy your own servers, without any additional research
                           on your part. However, if you are curious, you might want to visit the
                           <a href=theory.html>theory</a> page. Its purpose is to explain how the
                           framework actually performs its functions.

                           <a id="directory"></a><h3>Directory Structure</h3><br>

                           The project is organized into the following directories;<b><tt><pre>
/root                // this is the project directory
    /example         // this is the example of the project
        /include     // this is the proxy's resources repository
        /gui         // this is the proxy's graphical widgets
    /gnu             // this is the project's root directory
        /cajo        // this is the project's Java namespace
            /invoke  // this is the architecture's core
            /utils   // this is the framework's collection of tools
    /docs            // this is the documentation collection</pre>
                           </tt></b>

                           You will need to download the source code into the structure outlined above,
                           in a working directory. (you don't have to name it root though) <i>Note:</i> there
                           is also a www directory, but you don't need to download this. It's just the
                           HTML for this site, but you can if you really want to :-)<br><br>

                           In the <b>root directory</b>, you will find several files, all of these will be
                           covered in the course of this tutorial.  For now, the most important file is
                           the <a href=https://cajo.dev.java.net/source/browse/cajo/doc.bat>doc</a>
                           batch.  Invoking it will scan the project source, and create highly
                           detailed javadoc hypertext documents in the docs subdirectory.  This will be
                           a <u>very</u> valuable resource in your development activities. Nearly half of
                           the source code is documentation comments! You can view this helpful
                           resource by opening the file docs/index.html with your favorite browser. (My
                           <i><u>highly recommended</u></i> favorite is
                           <a href=http://mozilla.org/products/firefox/ target=_blank>firefox</a>).<br><br>

                           The <b>example directory</b> contains the four Java classes comprising the
                           example server.  The file Main.java is the server application itself. The
                           file TestItem is an item, meaning a small server-side functional module,
                           which is accessible to remote applications.  The file TestProxy is a proxy,
                           meaning a mobile functional module, which is sent to remote clients, and
                           communicates back to its item.  Servers can be made that do not use proxies,
                           it is simply here to demonstrate how to make one, and what it does. Finally
                           there is the file Builder.java.  Strictly speaking the example could have
                           been made without this class also, but it is here to demonstrate the process
                           of configuring proxies at compile time, rather than runtime.  It's a little
                           extra work, but it can make the proxies a lot smaller, simpler, and more
                           secure.<br><br>

                           The <b>gui directory</b> contains a small collection of graphical widgets
                           used by the proxy to create its user interface on hosting clients. They are
                           outside the scope of this project as a proxy is free to use the AWT, or
                           Swing, in any manner. <i>By all means</i>, please don't think this is the
                           graphical toolkit you'll have to use, it is here only for the purposes of
                           this example, and doesn't even merit detailed examination. (unless you really
                           want to)<br><br>

                           The <b>gnu/cajo/invoke</b> directory houses the core paradigm of this
                           framework.  Its files are described at length in the javadoc pages.
                           For now suffice it to say that it defines the single standard interface,
                           between which all items communicate.<br><br>

                           The <b>gnu/cajo/utils</b> directory applies the invoke package to create
                           the core framework. Likewise, these files are covered in detail in
                           the javadoc pages. For now it can be summarised as providing a collection
                           of classes used in the creation of clients, servers, and proxies.<br><br>

                           The <b>docs</b> directory, as mentioned previously, is where the
                           auto-generated documentation goes.  Initially it is empty, in fact <u>it
                           does not even exist</u> in the source repository.  You have to make this
                           directory yourself. Then when you run the documentation generating batch
                           file, it will create the files on your drive. (Don't worry, the documentation
                           is not huge, about 370kB.)

                           <a id="building"></a><h3>Building the example</h3><br>

                           There are three fundamental ways to build the example, represented by the
                           three batch files; make1.bat, make2.bat, and make3.bat. Each builds the
                           server with identical functionality; simply packaged in different ways.<br><br>

                           The <b>make1</b> batch creates the server in a single monolithic jar file.
                           Everything is contained inside it, the server itself, the test item, the test
                           proxy, and even a client applet, which allows browsers to host the proxy!
                           This file, and the security.policy file are all that is needed to deploy
                           the server.  All servers use the same policy file by default, so a deployment
                           directory could consist of many server jars, and a single policy
                           file.  This is an important part of the paradigm; to allow complex
                           functionality to be modularized into multiple Virtual Machines seamlessly
                           working together. <i>Note:</i> If you <i>really</i> need separate policy
                           files for each server, each server jar and its associated policy file would
                           go into separate directories.<br><br>

                           The <b>make2</b> batch creates the server in two files; server.jar and
                           client.jar. The client.jar is a stand-alone standard client application, in
                           addition to being a standard applet used by browsers to host the example
                           proxy. Deployment now consists of the server jar, the client jar (since the
                           server references it), and the policy file. All servers built this way
                           reference the same client jar, in the same way as they all reference the
                           same policy file. A stand-alone client not only reduces the server jar file
                           size, which can be helpful if there are many servers in the same directory,
                           it is also very useful in its own right. Using the standard
                           <a href=client.html>client</a> is a topic of its own, and as such gets its
                           own page.<br><br>

                           The <b>make3</b> batch creates the server as three files; server.jar
                           client.jar, and proxy.jar. Now deployment consists of four files, the three
                           jars, and the policy file. The reason to use make3, is if you want to take
                           advantage of the <i>"hot plugging"</i> capability of the framework.  This
                           means you can modify the proxy, or proxies, recompile their jar file, and
                           overwrite the existing proxy.jar file, all while the server is still running.
                           All subsequent clients will receive the updated functionality automatically,
                           and the server need never be shut down!
                           
                           <a id="launching"></a><h3>Launching the example</h3><br>

                           Once you have built the example, launching it can be as simple as executing
                           the following command:<br>
                           <pre>    <code>java -jar server.jar</code></pre>
                           This will start the server using its default settings:<ul>
                              <li>client and proxy code delivery on TCP port 80
                              <li>server item communication on TCP port 1099
                              <li>hostname is identical both inside and outside subnet
                              <li>default server network interface is being used
                              <li>the server port is the same both inside and outside the subnet
                           </ul>This should suffice for many users, however these five assumptions can
                           be overridden, as command line arguments. The options above progress from
                           most likely to need overriding, to least.<br><br>

                           <b>1.</b> Typically the first problem hit by most users is that port 80 is
                           not available. This can be for a variety of reasons; there is already an http
                           server running on the box, or you are using a *nix system and you are not
                           root, in any case, you are forced to select another port.  Fortunately this
                           is the first command argument. In this case, you will have to do something
                           like this:

                           <pre>    <code>java -jar server.jar 8080</code></pre>

                           This will start the http service for the client and proxy code on port 8080.
                           The only real impact is that the port must now be explicitly specified by
                           the client when connecting to the server, as it is no longer default. This
                           detail will be covered in the next section,
                           <a href=tutorial.html#connecting>connecting</a>.<br><br>

                           <b>2.</b> Often the next problem hit is that port 1099 is not available. Typically
                           this is because a central rmiregistry is running on the machine.  By default,
                           each cajo server uses its own rmiregistry, operating on the same port as the
                           interface to its items.  In any case, another port must be selected:

                           <pre>    <code>java -jar server.jar 8080 1234</code></pre>

                           This means that clients connect to this server on port 1234. <i>Note:</i>
                           the order and precedence of the arguments is required, meaning that if you
                           want to specify the server port, you must also specify the http port. (yes,
                           arguments could be handled in a more sophisticated fashion, but this is only
                           an <i>example</i> program)<br><br>

                           <b>3.</b> The next most common problem is that your server is behind a NAT router.
                           This happens, for example, when you want to share a single connection to the
                           Internet.  Essentially, the NAT router is giving you a <i>'fake'</i> IP
                           address valid only inside the subnet. It translates the addresses for you,
                           and everyone else sharing the connection, to the actual network address.
                           This means you need to know your outside IP address.  There are simple
                           programs to tell you your actual IP address.  For example, a nice one can be
                           found at <a href=http://www.ipmonster.com target=_blank>ipmonster</a>.
                           Another highly recommended option, if you are going to be serving a lot, is
                           to get a domain name.  This is not nearly as difficult or expensive as it
                           sounds. If you are willing to share one, it is very easy to get one for
                           <i>free</i>.  One handy place to do this is
                           <a href=http://www.dyndns.org target=_blank>dyndns</a>.  There you can
                           register a name, something like yourhost.dyndns.com, and they even have a
                           variety of utilities you can run to make sure that name always resolves to
                           your host, even if your network provider is constantly changing your address!
                           If you want to get <i>really</i> fancy, you can always buy a domain name.
                           Anyway, now you will have a command line that looks something like this:

                           <pre>    <code>java -jar server.jar 8080 1234 yourhost.dyndns.com</code></pre>
                           -or-
                           <pre>    <code>java -jar server.jar 8080 1234 123.123.123.123</code></pre>

                           Now clients will correctly connect to you on your actual address, and not use
                           the phony one that the NAT router gave your host.<br><br>

                           <b>4.</b> Next, lets assume your computer has two network adapters; a wired
                           connection to your LAN, and a wireless connection to the internet.  You will
                           need to specify on which IP address, in this case <i>physical</i> network
                           interface, you want to run.  In this case you would specify the local
                           interface address, even if it is running behind NAT.  This would be your
                           command line now:

                           <pre>    <code>java -jar server.jar 8080 1234 123.123.123.123 100.100.100.100</code></pre>

                           This would also be required if your machine is multi-homed, i.e. has multiple
                           <i>logical</i> network interfaces.  Generally speaking, multi-homing is guru
                           magic, if you don't know what the term means, it most likely doesn't apply to
                           you.<br><br>

                           <b>5.</b> The final, and most <i>obscure</i> option, is used to support port translation.
                           Essentially, this means that a router is taking connections, on your behalf
                           on one port, and routing it to your machine, on a another one. In this case
                           you would specify the outside port. As the last option, you have probably
                           already guessed it, PT is <i>advanced</i> guru magic. If you are doing this,
                           you already know what the command line would look like, but just for the rest
                           of us, here it is:

                           <pre>    <code>java -jar server.jar 8080 1234 guru.org 100.100.100.100 4321</code></pre>

                           Here a client connecting on port 4321 of the public address guru.org actually
                           connects to some internal machine at 100.100.100.100 on its port 1234. In this
                           case, if none of this makes any sense, it <u>definitely</u> doesn't apply to
                           you.

                           <a id="connecting"></a><h3>Connecting to the server</h3><br>

                           Connecting to this example is generally done using a browser.  You will need
                           to have the Java Plug-In installed, if you don't the server will cause your
                           browser prompt you if it can install it automatically. This is done to make
                           connections easy for end users, who may be technically unsophisticated.
                           Just as with launching the application, connecting could be as simple as
                           pointing your browser to:

                           <pre>    <code>http://yourserver</code></pre>

                           The proxy, which is graphical, will load and appear inside your browser,
                           full screen and dynamically resizable.<br><br>

                           Just as with the server, there are a similar set of options to configure the
                           client. This time let's start with the complete command, then explain its
                           optional components:

                           <pre>    <code>http://serverHost[:serverPort]/[clientPort][:localPort][-proxyName]</code></pre>

                           <ul>
                           <li>The <b>serverPort</b> value is specified when port 80 was not abvailable
                           for the server. Unspecified, it will be port 80. In our example with the
                           server options, it would be 8080.

                           <li>The <b>clientPort</b> value would indicate the inbound TCP port on which
                           the client would like to receive the server callbacks.  This would need to be
                           specified if the client was behind a firewall.  Unspecified it would be
                           anonymous, meaning randomly chosen by the server, at runtime.

                           <li>The <b>:localPort</b> value would be the client's internal port number if
                           it is being translated from the external port number.  Unspecified it will be
                           the same as clientPort. <i>Very few</i> people will ever need this option.

                           <li>The <b>-proxyName</b> value would be used when the server binds more than
                           one item.  This is the name under which the item would be bound in the
                           registry. Unspecified the name "main" will be used, as servers typically bind
                           their default item under that name.
                           </ul>

                           The server will correctly configure the client's remaining communications
                           settings, even when the client is operating behind a NAT router.<br><br>

                           Connecting can also be done using the generic <a href=client.html>client</a>
                           application. It is <i>highly recommended</i> to use this application for
                           development purposes.<br><br>

                           <b>*<u>New feature</u>:</b> you can now web start the client application!
                           Simply append an exclamation point (!) to the end of the URL!  It's very
                           cool, try it! I call it; <i>starting the application with a bang!</i>

                           <h3>Conclusion</h3><br>

                           This is the proverbial tip of the iceberg, but it should get you started.
                           If you have further questions, there are
                           <a href=https://cajo.dev.java.net/servlets/ProjectForumView>forums</a>
                           for this project, also there is a  more general RMI
                           <a href=http://forum.java.sun.com/forum.jsp?forum=58 target=_blank>forum</a>
                           at the Java Developers website.  Before posting however, please do your
                           <a href=http://catb.org/~esr/faqs/smart-questions.html target=_blank>homework</a>.
                           (<i>Disclaimer:</i> the previously cited link is <u>not</u> affiliated with
                           this project, rather provided merely for insight.) Often the answer you are
                           seeking can can be found in the source documentation, or on this site, and
                           typically <i>much</i> faster.<br><br>

                           <div align="center">
                              <font size="-2">
                                 <hr width="80%">
                                 The deeper you look, the more of the framework's power reveals itself to you.
                              </font>
                           </div>
<!-- end main.html -->
                     </td>
                  </tr>
               </table>
            </td>
         </tr>
      </table>
   </body>
</html>
